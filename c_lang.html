<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>kayiwen - C语言学习笔记</title>
    <style>
        /* 全局样式重置 */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            scroll-behavior: smooth; /* 平滑滚动锚点 */
        }

        /* 页面背景和基础样式 */
        body {
            background-color: #f5f5f5;
            color: #333;
            line-height: 1.6;
            display: flex; /* 侧边栏+主内容布局 */
            min-height: 100vh;
        }

        /* 侧边栏样式 - 与主页面保持一致 */
        .sidebar {
            width: 250px;
            background-color: #2c3e50;
            color: white;
            padding: 2rem 1rem;
            position: fixed; /* 固定侧边栏 */
            height: 100vh;
            box-shadow: 2px 0 5px rgba(0,0,0,0.1);
            overflow-y: auto; /* 内容过多时滚动 */
        }

        /* 侧边栏头像/个人信息 */
        .sidebar-profile {
            text-align: center;
            margin-bottom: 2rem;
        }

        .sidebar-profile img {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            object-fit: cover;
            border: 4px solid #3498db;
            margin-bottom: 1rem;
        }

        .sidebar-profile h2 {
            font-size: 1.4rem;
            margin-bottom: 0.5rem;
        }

        .sidebar-profile p {
            color: #bdc3c7;
            font-size: 0.9rem;
        }

        /* 侧边栏导航基础样式 */
        .sidebar-nav {
            list-style: none;
        }

        .sidebar-nav li {
            margin-bottom: 0.5rem;
        }

        /* 主导航项 */
        .nav-main-item {
            color: white;
            text-decoration: none;
            display: block;
            padding: 0.8rem 1rem;
            border-radius: 4px;
            transition: background-color 0.3s;
            font-weight: 500;
        }

        .nav-main-item:hover,
        .nav-main-item.active { /* 选中状态 */
            background-color: #3498db;
            color: white;
        }

        /* 学习笔记子菜单样式 */
        .submenu {
            list-style: none;
            margin-left: 1rem;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease;
        }

        /* 展开子菜单的触发类 */
        .submenu-open {
            max-height: 300px; /* 足够容纳子项 */
        }

        .submenu li {
            margin-bottom: 0.3rem;
        }

        .submenu a {
            color: #bdc3c7;
            text-decoration: none;
            display: block;
            padding: 0.6rem 1rem;
            border-radius: 4px;
            font-size: 0.9rem;
            transition: background-color 0.3s, color 0.3s;
        }

        .submenu a:hover {
            background-color: #34495e;
            color: #3498db;
        }

        /* 侧边栏底部联系方式 */
        .sidebar-contact {
            margin-top: 2rem;
            padding-top: 1rem;
            border-top: 1px solid #3498db;
        }

        .sidebar-contact a {
            color: #bdc3c7;
            text-decoration: none;
            display: flex;
            align-items: center;
            margin-bottom: 0.8rem;
            font-size: 0.9rem;
        }

        .sidebar-contact a:hover {
            color: #3498db;
        }

        .sidebar-contact i {
            margin-right: 0.5rem;
            font-size: 1rem;
        }

        /* 主内容区域 */
        .main-content {
            flex: 1;
            margin-left: 250px; /* 适配侧边栏宽度 */
            padding: 2rem;
        }

        /* 内容卡片样式 */
        .content-card {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            margin-bottom: 2rem;
        }

        .content-card h2 {
            color: #2c3e50;
            margin-bottom: 1.5rem;
            border-bottom: 2px solid #3498db;
            padding-bottom: 0.5rem;
        }

        .content-card h3 {
            color: #2c3e50;
            margin: 1.5rem 0 1rem;
            font-size: 1.2rem;
        }

        .content-card h4 {
            color: #3498db;
            margin: 1rem 0 0.5rem;
            font-size: 1.1rem;
        }

        /* 代码块样式（C语言笔记专用） */
        .code-block {
            background-color: #2d2d2d;
            color: #f8f8f2;
            padding: 1rem;
            border-radius: 4px;
            margin: 1rem 0;
            overflow-x: auto;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 0.9rem;
        }

        /* 笔记段落样式 */
        .note-paragraph {
            margin-bottom: 1rem;
            line-height: 1.8;
        }

        /* 重点提示样式 */
        .tip-box {
            background-color: #e8f4fd;
            border-left: 4px solid #3498db;
            padding: 1rem;
            margin: 1rem 0;
            border-radius: 0 4px 4px 0;
        }

        /* 按钮样式（强化白色字体） */
        .btn {
            display: inline-block;
            background-color: #3498db;
            color: #ffffff !important; /* 强制字体白色 */
            padding: 0.6rem 1.2rem;
            border-radius: 4px;
            text-decoration: none;
            transition: background-color 0.3s;
            border: none;
            cursor: pointer;
            font-weight: 500;
        }

        .btn:hover {
            background-color: #2980b9;
            color: #ffffff !important;
        }

        /* 页脚样式 */
        footer {
            text-align: center;
            color: #7f8c8d;
            padding: 1rem;
            margin-top: 2rem;
            font-size: 0.9rem;
        }

        /* 移动端响应式适配 */
        @media (max-width: 768px) {
            .sidebar {
                width: 100%;
                height: auto;
                position: relative;
                padding: 1rem;
            }

            .main-content {
                margin-left: 0;
                padding: 1rem;
            }

            .sidebar-profile {
                margin-bottom: 1rem;
            }

            .sidebar-profile img {
                width: 80px;
                height: 80px;
            }

            .sidebar-nav {
                display: flex;
                overflow-x: auto;
                gap: 0.5rem;
            }

            .sidebar-nav li {
                margin-bottom: 0;
            }

            .submenu {
                display: none;
            }

            .sidebar-contact {
                display: none;
            }
        }
    </style>
    <!-- 引入图标库 -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
</head>
<body>
<!-- 侧边栏（与主页面完全一致） -->
<aside class="sidebar">
    <div class="sidebar-profile">
        <!-- 【替换】头像路径 -->
        <img src="images/avatar.jpg" alt="个人头像">
        <!-- 【替换】你的名字 -->
        <h2>kayiwen</h2>
        <!-- 【替换】个人标签 -->
        <p> BJTU-CS | 持续学习中 </p>
    </div>

    <!-- 侧边栏导航 -->
    <ul class="sidebar-nav">
        <li><a href="index.html#profile" class="nav-main-item">个人简介</a></li>
        <li>
            <a href="index.html#notes" class="nav-main-item active" id="notes-trigger">学习笔记</a>
            <ul class="submenu submenu-open" id="notes-submenu">
                <!-- C语言页面高亮 -->
                <li><a href="c_lang.html" style="color: #3498db; background-color: #34495e;">C语言</a></li>
                <li><a href="c_plus.html">C++</a></li>
                <li><a href="python.html">Python</a></li>
                <li><a href="html_css.html">HTML/CSS</a></li>
            </ul>
        </li>
        <li><a href="index.html#inspiration" class="nav-main-item">灵感记录</a></li>
        <li><a href="index.html#contact" class="nav-main-item">联系方式</a></li>
    </ul>

    <!-- 侧边栏联系方式 -->
    <div class="sidebar-contact">
        <!-- 【替换】你的邮箱 -->
        <a href="mailto:kayiwen@outlook.com">
            <i class="fas fa-envelope"></i> kayiwen@outlook.com
        </a>
        <!-- 【替换】你的GitHub链接 -->
        <a href="https://github.com/kayi-er" target="_blank">
            <i class="fab fa-github"></i> github.com/kayi-er
        </a>
        <!-- 【替换】你的小红书链接 -->
        <a href="https://www.xiaohongshu.com/user/profile/5cd20855000000001203775f" target="_blank">
            <i class="fab fa-xiaohongshu"></i> 小红书@kayiii
        </a>
            <i class="fab fa-xiaohongshu"></i> 公众号：九无清酒
    </div>
</aside>

<!-- ===== 以下是你已完成的C语言笔记主体内容 ===== -->
<main class="main-content">
    <section class="content-card">
        <h2>C语言学习笔记</h2>

        <!-- 笔记目录 -->
        <div class="note-paragraph">
            <strong>笔记目录：</strong>
            <a href="#basic-syntax" style="color: #3498db; margin: 0 0.5rem;">1. 基础语法</a>
            <a href="#pointer" style="color: #3498db; margin: 0 0.5rem;">2. 指针核心</a>
            <a href="#array" style="color: #3498db; margin: 0 0.5rem;">3. 数组与字符串</a>
            <a href="#example" style="color: #3498db; margin: 0 0.5rem;">4. 实战示例</a>
        </div>

        <h3>Chap1 程序设计概述</h3>
        <p>核心结论：本章围绕程序设计的基础框架展开，介绍了程序设计语言的发展与特点、程序实现的软硬件环境、C程序的加工执行流程，以及程序设计的核心要素（数据结构与算法），为后续编程学习奠定理论基础。</p>
        <h4>1.1 程序设计语言</h4>
        <ul>
            <li>发展历程：从面向机器的机器语言（0/1序列）、汇编语言（助记符），演进到面向过程（如C、Pascal）和面向对象（如Java、C++）的高级语言。</li>
            <li>C语言特点：入门门槛低、功能丰富、支持底层操作、目标代码效率高、可移植性强，兼具高级语言易用性和低级语言灵活性，被誉为“中级语言”。</li>
            <li>核心地位：许多新语言借鉴C语言特性，其设计者获图灵奖，广泛应用于底层开发和复杂程序设计。</li>

        </ul>
        <p>&nbsp;</p>
        <h4>1.2 程序的实现环境</h4>
        <ul>
            <li>硬件环境：由输入设备（键盘、鼠标）、输出设备（显示器、打印机）、存储设备（内存、硬盘）和CPU（运算器+控制器）组成，是程序运行的物理基础。</li>
            <li>软件环境：包含操作系统（Windows、Linux）、编辑程序（记事本、VS Code）、编译程序、连接程序，常用集成开发环境（IDE）有Visual Studio、Dev-C++、VS Code，简化编程、编译、调试流程。</li>

        </ul>
        <p>&nbsp;</p>
        <h4>1.3 C程序的加工和执行</h4>
        <ul>
            <li><p>加工步骤：</p>
                <ol>
                    <li>编译：编译程序将源程序（.c）转换为机器语言目标程序（.obj），检查语法错误。</li>
                    <li>连接：连接程序将目标程序与运行系统、库模块组合，生成可执行程序（.exe）。</li>

                </ol>
            </li>
            <li><p>执行规则：C程序必须包含且仅包含一个<code>main</code>函数，程序从<code>main</code>函数开始执行，与<code>main</code>函数在代码中的位置无关。</p>
            </li>
            <li><p>示例：简单C程序（helloworld.c）</p>
                <pre><code class='language-c' lang='c'>/*程序名：helloworld.c */
/*功能：在屏幕上输出一行文本*/
#include &lt;stdio.h&gt;             /*文件包含  */
int main( )                   /*主函数    */
{                              /*函数体开始*/
    printf(&quot;Hello world!\n&quot;);   /*输出语句  */
    return 0;
}                             /*函数体结束*/
</code></pre>
            </li>

        </ul>
        <p>&nbsp;</p>
        <h4>1.4 程序设计基本概念</h4>
        <ul>
            <li><p>程序：解决特定问题的指令序列，核心包含两部分——数据描述（数据结构）和操作描述（算法）。</p>
            </li>
            <li><p>算法：解决问题的有限步骤集合，需满足有穷性、确定性、可行性，示例：</p>
                <ol>
                    <li>求5!：步骤1→1×2，步骤2→结果×3，步骤3→结果×4，步骤4→结果×5，最终得120。</li>
                    <li>找出三个数的最大值：S1输入a、b、c；S2比较a和b，取较大值存为MAX；S3比较MAX和c，更新MAX；S4输出MAX。</li>

                </ol>
            </li>
            <li><p>数据结构：数据的组织形式，描述数据的存储和关联方式（如整型、数组等）。</p>
            </li>
            <li><p>程序设计步骤：分析问题→确定算法→编程→运行调试→总结。</p>
            </li>

        </ul>
        <p>&nbsp;</p>
        <h3>Chap2 程序设计初步</h3>
        <p>核心结论：本章聚焦C程序的基础编写能力，涵盖程序结构规范、输入输出方法、数据类型体系、常量变量定义、运算符表达式及类型转换，是编写简单C程序的核心基础。</p>
        <h4>2.1 程序的基本结构</h4>
        <ul>
            <li><p>核心组成：</p>
                <ol>
                    <li><code>main</code>函数：程序入口，必须包含且仅一个，格式为<code>int main()</code>（需<code>return 0</code>）或<code>void main()</code>（无返回值）。</li>
                    <li>注释：<code>/* 多行注释 */</code>或<code>// 单行注释</code>，不参与编译，增强代码可读性。</li>
                    <li>预编译命令：以<code>#</code>开头，如<code>#include &lt;stdio.h&gt;</code>（引用标准输入输出库），需放在程序开头。</li>

                </ol>
            </li>
            <li><p>结构规则：函数体用<code>{}</code>包裹，语句以<code>;</code>结束，使用标准库函数需包含对应头文件。</p>
            </li>
            <li><p>示例：计算两数之和</p>
                <pre><code class='language-c' lang='c'>/*程序名：2_1_2.cpp*/
/*功能：计算两个整数的和并输出结果*/
#include &lt;stdio.h&gt;

int add(int x, int y)  // 自定义函数
{
    int z;
    z = x + y;
    return z;
}

int main()
{
   int i1, i2, sum;
   printf(&quot;请输入两个整数：&quot;);
   scanf(&quot;%d,%d&quot;, &amp;i1, &amp;i2);
   sum = add(i1, i2);
   printf(&quot;sum=%d\n&quot;, sum);
   return 0;
}
</code></pre>
            </li>

        </ul>
        <p>&nbsp;</p>
        <h4>2.2 数据的输入和输出</h4>
        <ul>
            <li><p>格式输出函数<code>printf</code>：</p>
                <ul>
                    <li><p>格式：<code>printf(&quot;格式控制串&quot;, 输出表列)</code>，格式控制串包含格式说明（<code>%d</code>整型、<code>%f</code>浮点型、<code>%c</code>字符型、<code>%s</code>字符串）、普通字符、转义字符（<code>\n</code>换行、<code>\t</code>制表符）。</p>
                    </li>
                    <li><p>示例：</p>
                        <pre><code class='language-c' lang='c'>int a = -1, b = 25;
float c = 12.35;
printf(&quot;%d,%5d\n&quot;, a, b);  // 输出：-1,   25
printf(&quot;a=%7.2f\n&quot;, c);   // 输出：a=  12.35
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p>格式输入函数<code>scanf</code>：</p>
                <ul>
                    <li><p>格式：<code>scanf(&quot;格式控制串&quot;, 地址表列)</code>，变量需加<code>&amp;</code>（地址符），格式说明与<code>printf</code>对应（<code>%lf</code>对应<code>double</code>）。</p>
                    </li>
                    <li><p>分隔规则：输入多个数据时，可用空格、换行或显式分隔符（如逗号）。</p>
                    </li>
                    <li><p>示例：</p>
                        <pre><code class='language-c' lang='c'>int n;
double x;
scanf(&quot;%d,%lf&quot;, &amp;n, &amp;x);  // 输入：23,2.345
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p>字符输入输出函数：</p>
                <ul>
                    <li><code>getchar()</code>：读单个字符，格式<code>char ch = getchar();</code>。</li>
                    <li><code>putchar(ch)</code>：输单个字符，格式<code>putchar(ch);</code>。</li>

                </ul>
            </li>
            <li><p>注意：<code>scanf</code>无法读取带空格的字符串，需用<code>fgets</code>或<code>scanf(&quot;%[^\n]&quot;, str)</code>。</p>
            </li>
            <li><p>转义字符对照表：</p>
            </li>

        </ul>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>转义字符</th><th>含义</th><th><a href='https://c.biancheng.net/c/ascii/'>ASCII</a> 码值（十进制）</th><th>详细解释</th></tr></thead>
            <tbody><tr><td>\a</td><td>警报（响铃）</td><td>7</td><td>发出系统提示音，通常用于引起用户注意。在某些系统中可能没有明显效果。</td></tr><tr><td>\b</td><td>退格</td><td>8</td><td>将光标位置向左移动一个字符。如果光标已经在行首，则行为可能因系统而异。</td></tr><tr><td>\f</td><td>换页</td><td>12</td><td>将光标移动到下一页的开头。在打印输出时很有用，但在屏幕输出中可能显示为空白字符。</td></tr><tr><td>\n</td><td>换行</td><td>10</td><td>将光标移动到下一行的开头。这是最常用的行结束符，用于文本的换行。</td></tr><tr><td>\r</td><td>回车</td><td>13</td><td>将光标移动到当前行的开头。通常与 \n 配合使用，在 Windows 系统中表示换行。</td></tr><tr><td>\t</td><td>水平制表符</td><td>9</td><td>将光标移动到下一个制表位置。通常用于对齐文本或创建缩进效果。</td></tr><tr><td>\v</td><td>垂直制表符</td><td>11</td><td>在支持的设备上，将光标向下移动到下一个垂直制表位置。在大多数现代终端中，效果可能与 \n 相同。</td></tr><tr><td>\</td><td>反斜杠</td><td>92</td><td>用于在字符串中表示一个字面意义上的反斜杠字符。</td></tr><tr><td>&#39;</td><td>单引号</td><td>39</td><td>用于在字符常量中表示一个字面意义上的单引号字符。</td></tr><tr><td>&quot;</td><td>双引号</td><td>34</td><td>用于在字符串常量中表示一个字面意义上的双引号字符。</td></tr><tr><td>\?</td><td>问号</td><td>63</td><td>用于表示字面意义上的问号，主要用于避免触发三字符序列。</td></tr><tr><td>\0</td><td>空字符（NULL）</td><td>0</td><td>表示字符串的结束。在 C 语言中，字符串以空字符结尾。</td></tr><tr><td>\xhh</td><td>十六进制值</td><td>-</td><td>表示一个十六进制值，其中 hh 是一个或多个十六进制数字。例如，\x41 表示字符 &#39;A&#39;。</td></tr><tr><td>\ooo</td><td>八进制值</td><td>-</td><td>表示一个八进制值，其中 ooo 是一到三个八进制数字。例如，\101 表示字符 &#39;A&#39;。</td></tr></tbody>
        </table></figure>
        <p>&nbsp;</p>
        <h4>2.3 基本概念</h4>
        <ul>
            <li>基本字符：数字（0-9）、字母（a-z/A-Z）、特殊字符、空白字符（空格、换行、制表符），非基本字符（双引号内除外）为非法字符。</li>
            <li>标识符：变量/函数名，规则为字母/下划线开头，由字母、数字、下划线组成，区分大小写（如<code>a</code>和<code>A</code>不同）。</li>
            <li>关键字：32个ANSI标准关键字（如<code>int</code>、<code>if</code>、<code>for</code>），不可用作标识符。</li>

        </ul>
        <p>&nbsp;</p>
        <h4>2.4 数据类型</h4>
        <ul>
            <li><p>基本数据类型：</p>
                <figure class='table-figure'><table>
                    <thead>
                    <tr><th>类型</th><th>细分类型</th><th>占用字节（常见）</th><th>取值范围</th><th>特点</th></tr></thead>
                    <tbody><tr><td>整型</td><td>int</td><td>4</td><td>-2³¹~2³¹-1</td><td>存储整数</td></tr><tr><td>&nbsp;</td><td>short</td><td>2</td><td>-32768~32767</td><td>短整型</td></tr><tr><td>&nbsp;</td><td>long</td><td>4</td><td>-2³¹~2³¹-1</td><td>长整型</td></tr><tr><td>实型（浮点型）</td><td>float</td><td>4</td><td>±(3.4×10⁻³⁸~3.4×10³⁸)</td><td>单精度，有效数字7-8位</td></tr><tr><td>&nbsp;</td><td>double</td><td>8</td><td>±(1.7×10⁻³⁰⁸~1.7×10³⁰⁸)</td><td>双精度，有效数字15-16位</td></tr><tr><td>字符型</td><td>char</td><td>1</td><td>-128~127（signed char）</td><td>存储ASCII码，可与整型通用</td></tr><tr><td>&nbsp;</td><td>unsigned char</td><td>1</td><td>0~255</td><td>无符号字符</td></tr></tbody>
                </table></figure>
            </li>
            <li><p>扩展类型：<code>unsigned</code>（无符号）修饰整型/字符型，<code>long long</code>（64位整型）。</p>
            </li>
            <li><p>格式说明符：</p>
            </li>

        </ul>
        <figure class='table-figure'><table>
            <thead>
            <tr><th style='text-align:left;' >格式说明符</th><th style='text-align:left;' >类型</th></tr></thead>
            <tbody><tr><td style='text-align:left;' >%c</td><td style='text-align:left;' >字符</td></tr><tr><td style='text-align:left;' >%d</td><td style='text-align:left;' >有符号整数</td></tr><tr><td style='text-align:left;' >%e 或 %E</td><td style='text-align:left;' >浮点数的科学计数法</td></tr><tr><td style='text-align:left;' >%f</td><td style='text-align:left;' >浮点值</td></tr><tr><td style='text-align:left;' >%g 或 %G</td><td style='text-align:left;' >类似于 %e 或%E</td></tr><tr><td style='text-align:left;' >%hi</td><td style='text-align:left;' >有符号整数(短整型)</td></tr><tr><td style='text-align:left;' >%hu</td><td style='text-align:left;' >无符号整数(短整型)</td></tr><tr><td style='text-align:left;' >%i</td><td style='text-align:left;' >无符号整数</td></tr><tr><td style='text-align:left;' >%l 或 %ld 或 %li</td><td style='text-align:left;' >长整型</td></tr><tr><td style='text-align:left;' >%lf</td><td style='text-align:left;' >双精度型</td></tr><tr><td style='text-align:left;' >%Lf</td><td style='text-align:left;' >长双精度型</td></tr><tr><td style='text-align:left;' >%lu</td><td style='text-align:left;' >无符号整数或无符号long</td></tr><tr><td style='text-align:left;' >%lli 或 %lld</td><td style='text-align:left;' >Long long</td></tr><tr><td style='text-align:left;' >%llu</td><td style='text-align:left;' >无符号 long long</td></tr><tr><td style='text-align:left;' >%o</td><td style='text-align:left;' >八进制表示</td></tr><tr><td style='text-align:left;' >%p</td><td style='text-align:left;' >指针</td></tr><tr><td style='text-align:left;' >%s</td><td style='text-align:left;' >字符串</td></tr><tr><td style='text-align:left;' >%u</td><td style='text-align:left;' >无符号 int</td></tr><tr><td style='text-align:left;' >%x 或 %X</td><td style='text-align:left;' >十六进制表示</td></tr></tbody>
        </table></figure>
        <p>&nbsp;</p>
        <h4>2.5 常量和变量</h4>
        <ul>
            <li><p>常量：程序运行中值不变的量，分类如下：</p>
                <ol>
                    <li><p>整型常量：十进制（123）、八进制（0123）、十六进制（0x12）。</p>
                    </li>
                    <li><p>实型常量：小数形式（12.3）、指数形式（1.23e2），后缀<code>f</code>表示<code>float</code>（否则为<code>double</code>）。</p>
                    </li>
                    <li><p>字符常量：单引号包裹（<code>&#39;a&#39;</code>），本质是ASCII码（<code>&#39;A&#39;=65</code>、<code>&#39;0&#39;=48</code>）。</p>
                    </li>
                    <li><p>转义字符：以<code>\</code>开头，如<code>\n</code>（换行）、<code>\t</code>（制表符）、<code>\0</code>（字符串结束符）、<code>\x41</code>（十六进制ASCII码）。</p>
                    </li>
                    <li><p>字符串常量：双引号包裹（<code>&quot;Good&quot;</code>），自动添加<code>\0</code>结束符，占字节数=字符数+1。</p>
                    </li>
                    <li><p>符号常量：<code>#define 符号常量名 常量</code>（无分号），示例：</p>
                        <pre><code class='language-c' lang='c'>#define PI 3.14159
int main() {
    float r = 2.0;
    float s = PI * r * r;
    printf(&quot;面积：%f\n&quot;, s);
    return 0;
}
</code></pre>
                    </li>

                </ol>
            </li>
            <li><p>变量：程序运行中值可变的量：</p>
                <ul>
                    <li>定义格式：<code>数据类型 变量名1, 变量名2;</code>（如<code>int a, b;</code>）。</li>
                    <li>初始化：定义时赋值（<code>int a=5;</code>），区别于赋值语句（运行时赋值），未初始化的自动变量值随机。</li>
                    <li>内存特性：不同类型占用不同字节，变量名对应内存地址，通过地址访问值。</li>

                </ul>
            </li>

        </ul>
        <p>&nbsp;</p>
        <h4>2.6 运算符与表达式</h4>
        <ul>
            <li><p>算术运算符：<code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code>（取模，仅整型）、<code>++</code>（自增）、<code>--</code>（自减）：</p>
                <ul>
                    <li><code>++i</code>（先运算后取值）、<code>i++</code>（先取值后运算）。</li>
                    <li>示例：<code>8%5=3</code>、<code>5/2=2</code>（整数除法舍弃小数）、<code>5.0/2=2.5</code>（实型除法）。</li>

                </ul>
            </li>
            <li><p>赋值运算符：<code>=</code>、<code>+=</code>、<code>-=</code>、<code>*=</code>、<code>/=</code>、<code>%=</code>，结合性自右向左（<code>a=b=c</code>等价于<code>a=(b=c)</code>）。</p>
            </li>
            <li><p>关系运算符：<code>&lt;</code>、<code>&lt;=</code>、<code>&gt;</code>、<code>&gt;=</code>、<code>==</code>（等于）、<code>!=</code>（不等于），返回值为1（真）或0（假），优先级低于算术运算符。</p>
            </li>
            <li><p>逻辑运算符：<code>!</code>（非）、<code>&amp;&amp;</code>（与，短路特性）、<code>||</code>（或，短路特性），优先级：<code>!</code>&gt;算术&gt;关系&gt;<code>&amp;&amp;</code>&gt;<code>||</code>&gt;赋值。</p>
            </li>
            <li><p>逗号运算符：<code>表达式1,表达式2</code>，结果为表达式2的值，优先级最低。</p>
            </li>
            <li><p>表达式：由运算符和运算对象组成，示例：</p>
                <ul>
                    <li>算术表达式：<code>(a+b+c)/3</code>、<code>sqrt(s*(s-a)*(s-b)*(s-c))</code>。</li>
                    <li>关系表达式：<code>a&gt;b</code>、<code>x&gt;=3&amp;&amp;x&lt;=5</code>。</li>
                    <li>逻辑表达式：<code>!a||(a&amp;&amp;b)</code>。</li>

                </ul>
            </li>

        </ul>
        <p>&nbsp;</p>
        <h4>2.7 数据类型的转换</h4>
        <ul>
            <li><p>自动转换（隐式转换）：</p>
                <ul>
                    <li>运算转换：“向高看齐”，低精度→高精度（<code>char</code>→<code>int</code>→<code>long</code>→<code>float</code>→<code>double</code>）。</li>
                    <li>赋值转换：右值→左值类型（实型→整型舍弃小数，整型→实型补0，长字节→短字节可能溢出）。</li>

                </ul>
            </li>
            <li><p>强制转换（显式转换）：格式<code>(类型标识符)表达式</code>，不改变原变量类型，示例：</p>
                <pre><code class='language-c' lang='c'>float x = 3.6;
int i = (int)x;  // i=3（舍弃小数，非四舍五入）
</code></pre>
            </li>

        </ul>
        <p>&nbsp;</p>
        <h4>2.8 数学函数</h4>
        <ul>
            <li><p>需包含头文件<code>&lt;math.h&gt;</code>，常用函数：</p>
                <figure class='table-figure'><table>
                    <thead>
                    <tr><th>函数名</th><th>功能</th><th>示例</th></tr></thead>
                    <tbody><tr><td><code>fabs(x)</code></td><td>求x的绝对值（实型）</td><td><code>fabs(-3.5)=3.5</code></td></tr><tr><td><code>sqrt(x)</code></td><td>求x的非负平方根</td><td><code>sqrt(16.0)=4.0</code></td></tr><tr><td><code>pow(x,y)</code></td><td>求x^y</td><td><code>pow(2.0,3.0)=8.0</code></td></tr><tr><td><code>sin(x)</code></td><td>正弦函数（x为弧度）</td><td><code>sin(0.0)=0.0</code></td></tr><tr><td><code>log(x)</code></td><td>自然对数lnx</td><td><code>log(2.71828)=1.0</code></td></tr></tbody>
                </table></figure>
            </li>
            <li><p>示例：计算三角形面积</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main() {
    double a, b, c, s, area;
    printf(&quot;请输入三角形三边：&quot;);
    scanf(&quot;%lf,%lf,%lf&quot;, &amp;a, &amp;b, &amp;c);
    s = (a + b + c) / 2.0;
    area = sqrt(s * (s - a) * (s - b) * (s - c));
    printf(&quot;面积：%7.2f\n&quot;, area);
    return 0;
}
</code></pre>
            </li>

        </ul>
        <p>&nbsp;</p>
        <h3>Chap3 程序控制结构</h3>
        <p>核心结论：本章围绕程序的三种基本控制结构（顺序、选择、循环）展开，详解关系/逻辑/条件表达式的用法，掌握if、switch选择语句和while、do-while、for循环语句的实现，结合循环控制语句（break/continue）和嵌套结构，解决实际编程问题。</p>
        <h4>3.1 关系表达式、逻辑表达式、条件表达式</h4>
        <p>这三类表达式是控制结构的核心判断依据，用于描述程序执行的条件。</p>
        <h5>3.1.1 关系表达式</h5>
        <ul>
            <li><p>关系运算符：共6个，分为两组优先级（高：<code>&lt;</code> <code>&lt;=</code> <code>&gt;</code> <code>&gt;=</code>；低：<code>==</code> <code>!=</code>），结合性自左向右。</p>
            </li>
            <li><p>表达式定义：用关系运算符连接两个表达式（算术、关系等），结果为逻辑值（1代表真，0代表假）。</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>int a=0, b=1, c=2;
printf(&quot;%d\n&quot;, a&lt;=c);    // 输出1（真）
printf(&quot;%d\n&quot;, a&lt;=c&lt;=b); // 输出1（等价于(a&lt;=c)&lt;=b，即1&lt;=1为真）
printf(&quot;%d\n&quot;, 5&gt;2&gt;7);   // 输出0（等价于(5&gt;2)&gt;7，即1&gt;7为假）
</code></pre>
            </li>
            <li><p>注意：避免浮点型用<code>==</code>/<code>!=</code>比较，需通过差值绝对值判断（如<code>fabs(x-1.0)&lt;=1e-6</code>）。</p>
            </li>

        </ul>
        <h5>3.1.2 逻辑表达式</h5>
        <ul>
            <li><p>逻辑运算符：<code>!</code>（非，单目）、<code>&amp;&amp;</code>（与）、<code>||</code>（或），优先级：<code>!</code>&gt;算术&gt;关系&gt;<code>&amp;&amp;</code>&gt;<code>||</code>&gt;赋值，结合性自左向右。</p>
            </li>
            <li><p>短路特性：</p>
                <ul>
                    <li><code>a&amp;&amp;b</code>：a为假时，不计算b（直接返回假）。</li>
                    <li><code>a||b</code>：a为真时，不计算b（直接返回真）。</li>

                </ul>
            </li>
            <li><p>真值表：</p>
                <figure class='table-figure'><table>
                    <thead>
                    <tr><th>a（非0为真）</th><th>b（非0为真）</th><th>!a</th><th>!b</th><th>a</th><th>b</th></tr></thead>
                    <tbody><tr><td>真</td><td>真</td><td>0</td><td>0</td><td>1</td><td>1</td></tr><tr><td>真</td><td>假</td><td>0</td><td>1</td><td>0</td><td>1</td></tr><tr><td>假</td><td>真</td><td>1</td><td>0</td><td>0</td><td>1</td></tr><tr><td>假</td><td>假</td><td>1</td><td>1</td><td>0</td><td>0</td></tr></tbody>
                </table></figure>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>int a=1, b=2, m=1, n=1;
(m=a&gt;b)&amp;&amp;(n=c&gt;d); // a&gt;b为0，m=0，n不计算仍为1
printf(&quot;m=%d, n=%d\n&quot;, m, n); // 输出m=0, n=1
</code></pre>
            </li>

        </ul>
        <h5>3.1.3 条件表达式</h5>
        <ul>
            <li><p>格式：<code>表达式1?表达式2:表达式3</code>，结合性自右向左。</p>
            </li>
            <li><p>执行流程：表达式1为真则取表达式2的值，否则取表达式3的值。</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>int max = a&gt;b?a:b; // 求两数最大值
int sign = x&gt;0?1:(x==0?0:-1); // 符号函数
</code></pre>
            </li>
            <li><p>注意：优先级高于赋值，低于关系/逻辑运算符，复杂条件需加括号明确优先级。</p>
            </li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>3.2 顺序结构程序设计</h4>
        <ul>
            <li><p>定义：语句按排列顺序逐行执行，无跳转，是最基础的程序结构。</p>
            </li>
            <li><p>组成语句：赋值语句、复合语句（<code>{}</code>包裹）、函数调用语句。</p>
            </li>
            <li><p>示例：计算工业产值（年增长率7.4%，20年后产值）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main() {
    int n;
    double p0, p1, r;
    scanf(&quot;%d,%lf,%lf&quot;, &amp;n, &amp;p0, &amp;r);
    p1 = p0 * pow(1 + r, n);
    printf(&quot;20年后产值：%10.4f\n&quot;, p1);
    return 0;
}
</code></pre>
            </li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>3.3 选择结构程序设计</h4>
        <p>选择结构根据条件判断执行不同分支，核心语句为<code>if</code>和<code>switch</code>。</p>
        <h5>3.3.1 if语句</h5>
        <ul>
            <li><p>三种形式：</p>
                <ol>
                    <li>单分支：<code>if(表达式) 语句;</code></li>
                    <li>双分支：<code>if(表达式) 语句1; else 语句2;</code></li>
                    <li>多分支：<code>if(表达式1) 语句1; else if(表达式2) 语句2; ... else 语句n;</code></li>

                </ol>
            </li>
            <li><p>嵌套规则：else与最近的未匹配if配对，建议用<code>{}</code>明确作用域。</p>
            </li>
            <li><p>示例1：判断闰年</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int year;
    printf(&quot;请输入年号：&quot;);
    scanf(&quot;%d&quot;, &amp;year);
    if ((year%4==0&amp;&amp;year%100!=0) || year%400==0)
        printf(&quot;%d是闰年\n&quot;, year);
    else
        printf(&quot;%d不是闰年\n&quot;, year);
    return 0;
}
</code></pre>
            </li>
            <li><p>示例2：求三个数的最大值</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int a, b, c, max;
    printf(&quot;请输入三个整数：&quot;);
    scanf(&quot;%d%d%d&quot;, &amp;a, &amp;b, &amp;c);
    if (a &gt; b) max = a;
    else max = b;
    if (c &gt; max) max = c;
    printf(&quot;最大值：%d\n&quot;, max);
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>3.3.2 switch语句</h5>
        <ul>
            <li><p>格式：</p>
                <pre><code class='language-c' lang='c'>switch(算术表达式) {
    case 常量表达式1: 语句组1; break;
    case 常量表达式2: 语句组2; break;
    ...
    default: 语句组n+1; // 可省略
}
</code></pre>
            </li>
            <li><p>说明：</p>
                <ul>
                    <li>表达式为整型/字符型/枚举型，case常量互不相等。</li>
                    <li><code>break</code>用于跳出switch，否则执行后续case（穿透特性）。</li>
                    <li>default可在任意位置，不影响执行逻辑。</li>

                </ul>
            </li>
            <li><p>示例：成绩等级评定</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int score, grade;
    printf(&quot;输入成绩（0~100）：&quot;);
    scanf(&quot;%d&quot;, &amp;score);
    grade = score / 10;
    switch(grade) {
        case 10:
        case 9: printf(&quot;等级A\n&quot;); break;
        case 8: printf(&quot;等级B\n&quot;); break;
        case 7: printf(&quot;等级C\n&quot;); break;
        case 6: printf(&quot;等级D\n&quot;); break;
        default: printf(&quot;等级E\n&quot;);
    }
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>3.3.3 应用举例：求解一元二次方程<code>ax²+bx+c=0</code></h5>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
int main() {
    double a, b, c, delta, k;
    scanf(&quot;%lf,%lf,%lf&quot;, &amp;a, &amp;b, &amp;c);
    if (a == 0) {
        if (b != 0)
            printf(&quot;唯一根：%f\n&quot;, -c/b);
        else if (c == 0)
            printf(&quot;无穷多根\n&quot;);
        else
            printf(&quot;无解\n&quot;);
    } else {
        delta = b*b - 4*a*c;
        if (delta == 0)
            printf(&quot;两个相同实根：%f\n&quot;, -b/(2*a));
        else if (delta &gt; 0)
            printf(&quot;两个不同实根：%f, %f\n&quot;,
                   (-b+sqrt(delta))/(2*a), (-b-sqrt(delta))/(2*a));
        else {
            k = sqrt(-delta)/(2*a);
            printf(&quot;两个虚根：%f+%fi, %f-%fi\n&quot;, -b/(2*a), k, -b/(2*a), k);
        }
    }
    return 0;
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>3.4 循环结构程序设计</h4>
        <p>循环结构重复执行某段语句，核心语句为<code>while</code>、<code>do-while</code>、<code>for</code>，用于处理重复任务。</p>
        <h5>3.4.1 while语句（当型循环）</h5>
        <ul>
            <li><p>格式：<code>while(表达式) 语句;</code></p>
            </li>
            <li><p>执行流程：先判断表达式，真则执行循环体，需包含使表达式变化的语句（避免死循环）。</p>
            </li>
            <li><p>特点：可能一次不执行循环体。</p>
            </li>
            <li><p>示例：计算1+2+...+10000</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int i=1, sum=0;
    while (i &lt;= 10000) {
        sum += i;
        i++;
    }
    printf(&quot;和：%d\n&quot;, sum);
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>3.4.2 do-while语句（直到型循环）</h5>
        <ul>
            <li><p>格式：<code>do { 语句; } while(表达式);</code></p>
            </li>
            <li><p>执行流程：先执行循环体，再判断表达式，至少执行一次。</p>
            </li>
            <li><p>示例：求满足<code>1+2+...+n&lt;500</code>的最大n</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int n=0, sum=0;
    do {
        n++;
        sum += n;
    } while (sum &lt; 500);
    printf(&quot;最大n：%d，和：%d\n&quot;, n-1, sum-n);
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>3.4.3 for语句</h5>
        <ul>
            <li><p>格式：<code>for(表达式1;表达式2;表达式3) 语句;</code></p>
                <ul>
                    <li>表达式1：初始化循环变量（可多个，逗号分隔）。</li>
                    <li>表达式2：循环条件（省略则为真，死循环）。</li>
                    <li>表达式3：更新循环变量（可多个，逗号分隔）。</li>

                </ul>
            </li>
            <li><p>灵活用法：可省略任意表达式（如<code>for(;;)</code>为死循环）。</p>
            </li>
            <li><p>示例：打印九九乘法表</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int i, j, m;
    printf(&quot;*&quot;);
    for (j=1; j&lt;=9; j++)
        printf(&quot;%4d&quot;, j);
    printf(&quot;\n&quot;);
    for (i=1; i&lt;=9; i++) {
        printf(&quot;%d&quot;, i);
        for (j=1; j&lt;=i; j++) {
            m = i*j;
            printf(&quot;%4d&quot;, m);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>3.4.4 循环控制语句（break/continue）</h5>
        <ul>
            <li><p><code>break</code>：跳出当前循环或switch语句，终止整个循环。</p>
            </li>
            <li><p><code>continue</code>：跳过本次循环剩余语句，进入下一次循环。</p>
            </li>
            <li><p>示例：打印100-200之间能被7整除的数</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    for (int n=100; n&lt;=200; n++) {
        if (n%7 != 0)
            continue; // 跳过非7的倍数，进入下一次循环
        printf(&quot;%5d&quot;, n);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>3.4.5 循环嵌套</h5>
        <ul>
            <li><p>定义：循环体内包含另一个循环，用于处理多维数据（如矩阵、表格）。</p>
            </li>
            <li><p>示例：斐波那契数列前12项（每行6项）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int f2=1, f1=1, f, n;
    printf(&quot;%-8d%-8d&quot;, f2, f1);
    for (n=3; n&lt;=12; n++) {
        f = f1 + f2;
        printf(&quot;%-8d&quot;, f);
        if (n%6 == 0)
            printf(&quot;\n&quot;);
        f2 = f1;
        f1 = f;
    }
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>3.4.6 应用举例</h5>
        <ol>
            <li>穷举法：搬砖问题（36块砖36人搬，男搬4、女搬3、两小孩搬1，一次搬完）</li>

        </ol>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int men, women, children;
    for (men=0; men&lt;=8; men++) { // 男最多搬32块，men&lt;=8
        for (women=0; women&lt;=11; women++) { // 女最多搬33块，women&lt;=11
            children = 36 - men - women;
            if (4*men + 3*women + children/2 == 36 &amp;&amp; children%2 == 0) {
                printf(&quot;男：%d，女：%d，小孩：%d\n&quot;, men, women, children);
            }
        }
    }
    return 0;
}
</code></pre>
        <ol start='2' >
            <li>迭代法：求斐波那契数列前12项（循环实现）</li>

        </ol>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int f[12] = {1, 1}; // 前两项为1
    for (int i=2; i&lt;12; i++) {
        f[i] = f[i-1] + f[i-2];
    }
    for (int i=0; i&lt;12; i++) {
        printf(&quot;%-6d&quot;, f[i]);
        if ((i+1)%6 == 0)
            printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
        <p>&nbsp;</p>
        <h3>Chap4 模块化程序设计——函数</h3>
        <p>核心结论：本章围绕模块化程序设计展开，详解函数的定义、调用、参数传递、多级调用（嵌套与递归），明确变量的作用域与存储类别，介绍编译预处理命令，实现复杂问题的拆分与高效解决，是C语言结构化编程的核心。</p>
        <h4>4.1 函数概述</h4>
        <p>函数是完成特定功能的独立程序模块，是C语言模块化编程的核心，可将复杂问题拆分为多个子问题逐一解决。</p>
        <h5>4.1.1 函数的分类</h5>
        <ul>
            <li>库函数：由C语言系统提供，如<code>printf</code>、<code>scanf</code>，使用时需包含对应头文件（如<code>#include &lt;stdio.h&gt;</code>）。</li>
            <li>自定义函数：用户根据需求自行定义，用于实现特定功能（如求面积、排序等）。</li>

        </ul>
        <h5>4.1.2 函数的核心规则</h5>
        <ul>
            <li>程序入口：一个完整C程序必须且仅包含一个<code>main</code>函数，程序从<code>main</code>函数开始执行。</li>
            <li>不能嵌套定义：函数定义不能嵌套在另一个函数内部，需单独定义。</li>
            <li>功能独立：每个函数应完成单一、明确的功能，增强代码可读性和复用性。</li>

        </ul>
        <h5>4.1.3 函数的作用</h5>
        <ul>
            <li>简化代码：避免重复编写相同逻辑，减少冗余。</li>
            <li>便于维护：单个功能模块修改不影响其他部分。</li>
            <li>拆分复杂问题：将大问题分解为小模块，降低编程难度。</li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>4.2 函数的定义和调用</h4>
        <p>函数的使用需遵循“先定义后调用”或“先声明后调用”的原则，核心包括定义格式、调用形式、参数传递和返回值处理。</p>
        <h5>4.2.1 函数的定义</h5>
        <p>函数定义分为“有返回值”和“无返回值”两种形式：</p>
        <ol>
            <li><p>有返回值函数（用于返回运算结果）：</p>
                <pre><code class='language-c' lang='c'>函数类型 函数名(形参表) {
    函数体（变量定义、执行语句）
    return 表达式; // 返回值类型与函数类型一致
}
</code></pre>
                <p>示例：求圆盘面积</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
double c_area(double r) { // 函数类型为double，形参r为double型
    return r * r * 3.1416; // 返回面积
}
</code></pre>
            </li>
            <li><p>无返回值函数（仅执行操作，无返回结果）：</p>
                <pre><code class='language-c' lang='c'>void 函数名(形参表) {
    函数体
    return; // 可省略，仅用于结束函数
}
</code></pre>
                <p>示例：打印圆盘面积</p>
                <pre><code class='language-c' lang='c'>void pc_area(double r) { // void表示无返回值
    printf(&quot;Radius:%f, area:%f\n&quot;, r, c_area(r));
}
</code></pre>
            </li>

        </ol>
        <h5>4.2.2 函数的调用</h5>
        <ol>
            <li><p>调用形式：</p>
                <ul>
                    <li>作为语句：无返回值函数的调用（如<code>pc_area(3.24);</code>）。</li>
                    <li>作为表达式：有返回值函数的调用（如<code>double s = c_area(2.13);</code>）。</li>
                    <li>作为实参：函数调用作为其他函数的参数（如<code>printf(&quot;%f&quot;, c_area(0.865));</code>）。</li>

                </ul>
            </li>
            <li><p>参数传递：</p>
                <ul>
                    <li>形参：函数定义时的参数（如<code>c_area(double r)</code>中的<code>r</code>），仅在函数内有效。</li>
                    <li>实参：函数调用时的参数（如<code>c_area(3.24)</code>中的<code>3.24</code>），需与形参数量、类型、顺序一致。</li>
                    <li>传递规则：C语言采用“值传递”，实参值单向传递给形参，形参修改不影响实参。
                        示例：参数传递的单向性</li>

                </ul>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void exch(int x, int y) { // 形参x、y
    int t = x; x = y; y = t; // 仅修改形参
}
int main() {
    int a=2, b=5;
    exch(a, b); // 实参a、b
    printf(&quot;a=%d, b=%d\n&quot;, a, b); // 输出a=2, b=5，实参未变
    return 0;
}
</code></pre>
            </li>
            <li><p>函数返回值：</p>
                <ul>
                    <li><code>return</code>语句用于返回结果，一个函数最多返回一个值。</li>
                    <li>主函数<code>main</code>的返回值：默认类型为<code>int</code>，返回0表示程序正常结束，非0表示出错。</li>

                </ul>
            </li>
            <li><p>函数原型声明：</p>
                <ul>
                    <li><p>若自定义函数在主调函数之后定义，需在调用前声明函数原型，格式：</p>
                        <pre><code class='language-c' lang='c'>函数类型 函数名(形参类型1, 形参类型2, ...); // 省略形参名也可
</code></pre>
                        <p>示例：函数原型声明</p>
                    </li>

                </ul>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
double c_area(double); // 函数原型声明（省略形参名）
int main() {
    printf(&quot;Area:%f\n&quot;, c_area(3.24)); // 调用前已声明
    return 0;
}
double c_area(double r) { // 函数定义在主函数之后
    return r * r * 3.1416;
}
</code></pre>
            </li>

        </ol>
        <hr />
        <p>&nbsp;</p>
        <h4>4.3 函数的多级调用</h4>
        <p>函数的多级调用包括“嵌套调用”（函数内调用其他函数）和“递归调用”（函数调用自身），用于解决复杂逻辑问题。</p>
        <h5>4.3.1 嵌套调用</h5>
        <ul>
            <li><p>定义：一个函数调用另一个函数，被调用函数再调用第三个函数，形成层级调用。</p>
            </li>
            <li><p>示例：弦截法求方程根（<code>main</code>调用<code>root</code>，<code>root</code>调用<code>xpoint</code>，<code>xpoint</code>调用<code>f</code>）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;math.h&gt;
double f(double x) { // 计算方程值
    return x*x*x - 5*x*x + 16*x - 80;
}
double xpoint(double x1, double x2) { // 求弦与x轴交点
    return (x1*f(x2) - x2*f(x1))/(f(x2)-f(x1));
}
double root(double x1, double x2) { // 求方程根
    double x = xpoint(x1, x2);
    while (fabs(f(x)) &gt;= 1e-6) {
        x = xpoint(x, x2);
    }
    return x;
}
int main() {
    double x1=2, x2=5;
    printf(&quot;方程的根：%f\n&quot;, root(x1, x2));
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>4.3.2 递归调用</h5>
        <ul>
            <li>定义：函数直接或间接调用自身，需满足“递归公式”和“终止条件”（避免死循环）。</li>
            <li>核心条件：1. 递归公式（n与n-1的关系）；2. 终止条件（n=1或n=0时的基例）。</li>

        </ul>
        <ol>
            <li><p>递归示例1：求n!（阶乘）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
unsigned long fact(int n) {
    if (n == 1) return 1; // 终止条件
    else return n * fact(n-1); // 递归公式：n! = n*(n-1)!
}
int main() {
    int x;
    printf(&quot;请输入正整数：&quot;);
    scanf(&quot;%d&quot;, &amp;x);
    printf(&quot;%d! = %ld\n&quot;, x, fact(x));
    return 0;
}
</code></pre>
            </li>
            <li><p>递归示例2：斐波那契数列第n项</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
long fibo(int n) {
    if (n == 1 || n == 2) return 1; // 终止条件
    else return fibo(n-1) + fibo(n-2); // 递归公式：f(n)=f(n-1)+f(n-2)
}
int main() {
    int n;
    scanf(&quot;%d&quot;, &amp;n);
    printf(&quot;第%d项：%ld\n&quot;, n, fibo(n));
    return 0;
}
</code></pre>
            </li>
            <li><p>递归示例3：汉诺塔问题</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void moveone(char from, char to) { // 移动一个金盘
    printf(&quot;%c -&gt; %c\n&quot;, from, to);
}
void hanoi(int n, char from, char by, char to) {
    if (n == 1) moveone(from, to); // 终止条件：1个金盘直接移动
    else {
        hanoi(n-1, from, to, by); // 把n-1个从from移到by
        moveone(from, to); // 把第n个从from移到to
        hanoi(n-1, by, from, to); // 把n-1个从by移到to
    }
}
int main() {
    hanoi(3, &#39;A&#39;, &#39;B&#39;, &#39;C&#39;); // 3个金盘从A移到C，B为中间柱
    return 0;
}
</code></pre>
            </li>

        </ol>
        <hr />
        <p>&nbsp;</p>
        <h4>4.4 变量与函数</h4>
        <p>变量按“作用域”和“存储类别”分类，核心是明确变量的可用范围和生命周期。</p>
        <h5>4.4.1 按作用域分类</h5>
        <ol>
            <li><p>局部变量：</p>
                <ul>
                    <li>定义位置：函数内、复合语句内（包括形参）。</li>
                    <li>作用域：仅在定义它的函数或复合语句内有效。</li>
                    <li>特点：函数调用时分配内存，调用结束释放；未初始化时值随机。
                        示例：</li>

                </ul>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void func() {
    int a = 10; // 局部变量，仅func内有效
    printf(&quot;func内a：%d\n&quot;, a);
}
int main() {
    func();
    // printf(&quot;%d&quot;, a); // 错误：a是func的局部变量，主函数不可用
    return 0;
}
</code></pre>
            </li>
            <li><p>全局变量：</p>
                <ul>
                    <li>定义位置：函数外部，不属于任一函数。</li>
                    <li>作用域：从定义处到源文件结束，可被多个函数访问。</li>
                    <li>特点：程序运行期间始终占用内存；未初始化时自动赋0；若与局部变量同名，局部变量优先。
                        示例：</li>

                </ul>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int a = 2; // 全局变量
void exch() {
    a = 5; // 访问全局变量
}
int main() {
    printf(&quot;修改前a：%d\n&quot;, a);
    exch();
    printf(&quot;修改后a：%d\n&quot;, a); // 输出5，全局变量被修改
    return 0;
}
</code></pre>
            </li>

        </ol>
        <h5>4.4.2 按存储类别分类</h5>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>存储类别</th><th>关键字</th><th>存储区域</th><th>生命周期</th><th>特点</th></tr></thead>
            <tbody><tr><td>自动变量</td><td>auto</td><td>动态存储区</td><td>函数调用期间</td><td>局部变量默认类型，未初始化值随机</td></tr><tr><td>静态变量</td><td>static</td><td>静态存储区</td><td>程序运行期间</td><td>局部静态变量初始化仅一次，值保留；全局静态变量仅本源文件可用</td></tr><tr><td>寄存器变量</td><td>register</td><td>寄存器</td><td>函数调用期间</td><td>频繁使用的局部变量，提高效率，不能取地址</td></tr><tr><td>外部变量</td><td>extern</td><td>静态存储区</td><td>程序运行期间</td><td>引用其他文件的全局变量</td></tr></tbody>
        </table></figure>
        <p>示例：静态局部变量</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void test() {
    static int y = 20; // 静态局部变量，初始化仅一次
    int x; // 自动变量，每次调用重新初始化
    if (1) x = 10;
    printf(&quot;auto:x=%d, static:y=%d\n&quot;, x, y++);
}
int main() {
    test(); // 输出：auto:x=10, static:y=20
    test(); // 输出：auto:x=随机值, static:y=21
    return 0;
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>4.5 编译预处理</h4>
        <p>编译预处理是编译前的预处理操作，以<code>#</code>开头，用于简化编程、提高代码通用性，包括文件包含、宏定义、条件编译。</p>
        <h5>4.5.1 文件包含（#include）</h5>
        <ul>
            <li><p>功能：将指定文件内容嵌入当前源文件。</p>
            </li>
            <li><p>两种格式：</p>
                <ol>
                    <li><code>#include &lt;文件名&gt;</code>：用于系统头文件（如<code>#include &lt;stdio.h&gt;</code>），从系统目录查找。</li>
                    <li><code>#include &quot;文件名&quot;</code>：用于自定义文件（如<code>#include &quot;abc.h&quot;</code>），先从当前目录查找，再查系统目录。</li>

                </ol>
            </li>
            <li><p>示例：自定义头文件引用</p>
                <pre><code class='language-c' lang='c'>// abc.h（头文件）
#define PI 3.14159
double c_area(double r); // 函数声明
</code></pre>
                <pre><code class='language-c' lang='c'>// abc.c（源文件）
#include &quot;abc.h&quot;
double c_area(double r) {
    return PI * r * r; // 使用头文件中的宏定义
}
</code></pre>
            </li>

        </ul>
        <h5>4.5.2 宏定义（#define）</h5>
        <ul>
            <li>功能：定义宏名替代正文，实现文本替换（预处理阶段完成）。</li>

        </ul>
        <ol>
            <li><p>简单宏定义：</p>
                <pre><code class='language-c' lang='c'>#define 宏名 替代正文 // 无分号
</code></pre>
                <p>示例：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#define NUM 30 // 宏定义：NUM替代30
int main() {
    printf(&quot;%d\n&quot;, NUM); // 预处理后替换为printf(&quot;%d\n&quot;, 30);
    return 0;
}
</code></pre>
            </li>
            <li><p>带参数宏定义：</p>
                <pre><code class='language-c' lang='c'>#define 宏名(参数表) 替代正文 // 宏名与括号间无空格
</code></pre>
                <p>示例：求两数最小值</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#define min(A,B) ((A)&lt;(B)?(A):(B)) // 加括号避免优先级问题
int main() {
    int x=5, y=3;
    printf(&quot;最小值：%d\n&quot;, min(x+y, x*y)); // 替换为((5+3)&lt;(5*3)?(5+3):(5*3))
    return 0;
}
</code></pre>
                <p>注意：带参数宏是文本替换，非函数调用，需避免优先级陷阱（加括号）。</p>
            </li>

        </ol>
        <h5>4.5.3 条件编译（#if...#else...#endif）</h5>
        <ul>
            <li><p>功能：按条件选择性编译代码，用于程序移植、调试。</p>
            </li>
            <li><p>格式：</p>
                <pre><code class='language-c' lang='c'>#if 条件表达式
    代码段1 // 条件为真时编译
#else
    代码段2 // 条件为假时编译
#endif
</code></pre>
                <p>示例：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#define DEBUG 1 // 调试模式开启
int main() {
    int a=10;
#if DEBUG
    printf(&quot;调试信息：a=%d\n&quot;, a); // 调试模式下编译
#else
    printf(&quot;a的值\n&quot;); // 非调试模式下编译
#endif
    return 0;
}
</code></pre>
            </li>

        </ul>
        <p>&nbsp;</p>
        <h3>Chap5 构造数据类型</h3>
        <p>核心结论：本章聚焦C语言构造数据类型的应用，涵盖数组（一维、二维、字符数组）和结构体类型两大核心，详解其定义、初始化、引用规则、内存存储特性及实际应用（排序、矩阵操作、字符串处理、数据封装），是处理批量数据和复杂结构化数据的核心基础。</p>
        <h4>5.1 数组概述</h4>
        <p>数组是由<strong>相同数据类型</strong>的元素按<strong>有序排列</strong>组成的构造类型，用于存储批量同类数据，解决单个变量无法高效处理多数据的问题。</p>
        <h5>核心特点</h5>
        <ul>
            <li>元素类型一致：所有元素的数据类型相同，占用内存大小一致。</li>
            <li>存储连续：元素在内存中占用连续存储空间，数组名代表首元素地址（地址常量）。</li>
            <li>下标访问：通过“数组名[下标]”访问元素，下标从0开始计数。</li>
            <li>用途：存储批量数据（如学生成绩、矩阵元素、字符串），方便批量处理。</li>

        </ul>
        <h5>数组分类</h5>
        <ul>
            <li>按维度：一维数组（线性数据）、二维数组（矩阵数据）、多维数组。</li>
            <li>按元素类型：数值数组（int、float）、字符数组（char）、结构体数组等。</li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>5.2 一维数组</h4>
        <p>一维数组是最基础的数组形式，用于存储线性排列的批量数据。</p>
        <h5>5.2.1 定义格式</h5>
        <pre><code class='language-c' lang='c'>类型说明符 数组名[常量表达式];
</code></pre>
        <ul>
            <li><p>类型说明符：指定数组元素的数据类型（int、float、char等）。</p>
            </li>
            <li><p>数组名：符合标识符规则，代表数组首地址。</p>
            </li>
            <li><p>常量表达式：指定数组元素个数（必须为非负常量，不能是变量）。</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>int a[5];      // 5个int型元素的一维数组
char c[20];    // 20个char型元素的一维数组
float x[10];    // 10个float型元素的一维数组
</code></pre>
            </li>

        </ul>
        <h5>5.2.2 初始化方式</h5>
        <p>一维数组初始化有4种常见形式，未初始化的自动变量元素值随机，静态数组自动赋0：</p>
        <ol>
            <li><p>全量初始化：指定所有元素值</p>
                <pre><code class='language-c' lang='c'>int a[5] = {1, 2, 3, 4, 5}; // a[0]=1, a[1]=2, ..., a[4]=5
</code></pre>
            </li>
            <li><p>部分初始化：未指定的元素自动赋0</p>
                <pre><code class='language-c' lang='c'>int a[5] = {1, 0, 1}; // a[0]=1, a[1]=0, a[2]=1, a[3]=0, a[4]=0
</code></pre>
            </li>
            <li><p>省略数组长度：由初始化元素个数自动确定长度</p>
                <pre><code class='language-c' lang='c'>int b[] = {1, 2, 3}; // 数组长度为3，b[0]=1, b[1]=2, b[2]=3
</code></pre>
            </li>
            <li><p>静态数组初始化：静态存储区数组自动赋0</p>
                <pre><code class='language-c' lang='c'>static int a[5]; // 所有元素均为0
</code></pre>
            </li>

        </ol>
        <h5>5.2.3 元素引用规则</h5>
        <ul>
            <li><p>引用格式：<code>数组名[下标]</code>，下标范围为<code>0 ~ 数组长度-1</code>（超出范围会数组越界）。</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>int a[5] = {1,2,3,4,5};
printf(&quot;%d&quot;, a[2]); // 输出3（引用第3个元素）
a[3] = 10;          // 修改第4个元素值为10
</code></pre>
            </li>
            <li><p>注意：不能直接引用整个数组（如<code>printf(&quot;%d&quot;, a)</code>），需逐个元素操作。</p>
            </li>

        </ul>
        <h5>5.2.4 输入输出</h5>
        <p>通过循环逐个读写元素，示例：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int a[10], i;
    // 输入
    printf(&quot;请输入10个整数：&quot;);
    for (i = 0; i &lt; 10; i++) {
        scanf(&quot;%d&quot;, &amp;a[i]); // 注意取地址符&amp;
    }
    // 输出
    printf(&quot;输出结果：&quot;);
    for (i = 0; i &lt; 10; i++) {
        printf(&quot;%4d&quot;, a[i]);
    }
    printf(&quot;\n&quot;);
    return 0;
}
</code></pre>
        <h5>5.2.5 应用举例</h5>
        <ol>
            <li><p>冒泡排序（从小到大）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#define N 5
int main() {
    int a[N], i, j, med;
    // 输入数据
    printf(&quot;请输入%d个整数：&quot;, N);
    for (i = 0; i &lt; N; i++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
    }
    // 冒泡排序
    for (i = 1; i &lt; N; i++) { // 控制轮数（N-1轮）
        for (j = 0; j &lt; N - i; j++) { // 每轮比较次数
            if (a[j] &gt; a[j+1]) { // 相邻元素比较，大的后移
                med = a[j];
                a[j] = a[j+1];
                a[j+1] = med;
            }
        }
    }
    // 输出结果
    printf(&quot;排序后：&quot;);
    for (i = 0; i &lt; N; i++) {
        printf(&quot;%4d&quot;, a[i]);
    }
    return 0;
}
</code></pre>
            </li>
            <li><p>选择排序（从小到大）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#define N 7
int main() {
    int a[N], i, j, med;
    printf(&quot;请输入%d个整数：&quot;, N);
    for (i = 0; i &lt; N; i++) {
        scanf(&quot;%d&quot;, &amp;a[i]);
    }
    // 选择排序
    for (i = 0; i &lt; N - 1; i++) { // 控制选择轮数（N-1轮）
        for (j = i + 1; j &lt; N; j++) { // 从剩余元素中找最小值
            if (a[j] &lt; a[i]) { // 最小值交换到当前位置
                med = a[i];
                a[i] = a[j];
                a[j] = med;
            }
        }
    }
    printf(&quot;排序后：&quot;);
    for (i = 0; i &lt; N; i++) {
        printf(&quot;%6d&quot;, a[i]);
    }
    return 0;
}
</code></pre>
            </li>

        </ol>
        <hr />
        <p>&nbsp;</p>
        <h4>5.3 二维数组</h4>
        <p>二维数组用于存储矩阵形式的数据（行×列），本质是“数组的数组”（每个元素是一维数组）。</p>
        <h5>5.3.1 定义格式</h5>
        <pre><code class='language-c' lang='c'>类型说明符 数组名[行数][列数];
</code></pre>
        <ul>
            <li><p>行数：二维数组的行数（可省略，由初始化自动推导）。</p>
            </li>
            <li><p>列数：二维数组的列数（不可省略）。</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>float a[5][4];  // 5行4列的float型二维数组
int b[3][6];    // 3行6列的int型二维数组
char str[30][20];// 30行20列的char型二维数组（存储30个字符串）
</code></pre>
            </li>

        </ul>
        <h5>5.3.2 内存存储规则</h5>
        <ul>
            <li>行优先存储：元素按“先存第0行，再存第1行……”的顺序连续存储。</li>
            <li>示例（<code>int a[2][3]</code>）：
                内存顺序为：a[0][0] → a[0][1] → a[0][2] → a[1][0] → a[1][1] → a[1][2]</li>
            <li>地址表示：<code>a[i][j]</code> 等价于 <code>*(a[i] + j)</code> 或 <code>*(*(a + i) + j)</code>（a为行地址，a[i]为首元素地址）。</li>

        </ul>
        <h5>5.3.3 初始化方式</h5>
        <ol>
            <li><p>分行初始化（推荐，清晰直观）</p>
                <pre><code class='language-c' lang='c'>int a[2][3] = {{1,2,3}, {4,5,6}}; // 全量初始化
int b[2][3] = {{1,2}, {4}};      // 部分初始化，未赋值元素为0
int c[][3] = {{1}, {4,5}};       // 省略行数，自动推导为2行
</code></pre>
            </li>
            <li><p>按存储顺序初始化（不推荐，可读性差）</p>
                <pre><code class='language-c' lang='c'>int a[2][3] = {1,2,3,4,5,6};    // 等价于分行初始化
int b[][3] = {1,2,3,4,5};      // 自动推导为2行，b[1][2]=0
</code></pre>
            </li>

        </ol>
        <h5>5.3.4 元素引用</h5>
        <ul>
            <li><p>格式：<code>数组名[行下标][列下标]</code>，行、列下标均从0开始。</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>int a[3][4] = {{1,2,3,4}, {5,6,7,8}, {9,10,11,12}};
printf(&quot;%d&quot;, a[1][2]); // 输出7（第2行第3列元素）
a[2][3] = 15;          // 修改第3行第4列元素为15
</code></pre>
            </li>

        </ul>
        <h5>5.3.5 输入输出</h5>
        <p>通过双重循环实现，外循环控制行，内循环控制列：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int b[3][2], i, j;
    // 输入
    printf(&quot;请输入3行2列数据：\n&quot;);
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 2; j++) {
            scanf(&quot;%d&quot;, &amp;b[i][j]);
        }
    }
    // 输出
    printf(&quot;输出矩阵：\n&quot;);
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 2; j++) {
            printf(&quot;b[%d][%d] = %d &quot;, i, j, b[i][j]);
        }
        printf(&quot;\n&quot;); // 换行
    }
    return 0;
}
</code></pre>
        <h5>5.3.6 应用举例</h5>
        <ol>
            <li><p>两3×4矩阵求和</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int a[3][4], b[3][4], c[3][4], i, j;
    // 输入矩阵a
    printf(&quot;请输入a矩阵元素：\n&quot;);
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 4; j++) {
            scanf(&quot;%d&quot;, &amp;a[i][j]);
        }
    }
    // 输入矩阵b
    printf(&quot;请输入b矩阵元素：\n&quot;);
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 4; j++) {
            scanf(&quot;%d&quot;, &amp;b[i][j]);
        }
    }
    // 矩阵求和
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 4; j++) {
            c[i][j] = a[i][j] + b[i][j];
        }
    }
    // 输出结果
    printf(&quot;a矩阵：\n&quot;);
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 4; j++) {
            printf(&quot;%5d&quot;, a[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    printf(&quot;b矩阵：\n&quot;);
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 4; j++) {
            printf(&quot;%5d&quot;, b[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    printf(&quot;和矩阵：\n&quot;);
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 4; j++) {
            printf(&quot;%5d&quot;, c[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
            </li>
            <li><p>4×3矩阵转置（转为3×4矩阵）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int a[4][3], b[3][4], i, j;
    // 输入原矩阵a
    printf(&quot;请输入4行3列矩阵A：\n&quot;);
    for (i = 0; i &lt; 4; i++) {
        for (j = 0; j &lt; 3; j++) {
            scanf(&quot;%d&quot;, &amp;a[i][j]);
        }
    }
    // 转置：b[j][i] = a[i][j]
    for (i = 0; i &lt; 4; i++) {
        for (j = 0; j &lt; 3; j++) {
            b[j][i] = a[i][j];
        }
    }
    // 输出原矩阵
    printf(&quot;原矩阵A：\n&quot;);
    for (i = 0; i &lt; 4; i++) {
        for (j = 0; j &lt; 3; j++) {
            printf(&quot;%6d&quot;, a[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    // 输出转置矩阵
    printf(&quot;转置矩阵B：\n&quot;);
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 4; j++) {
            printf(&quot;%6d&quot;, b[i][j]);
        }
        printf(&quot;\n&quot;);
    }
    return 0;
}
</code></pre>
            </li>
            <li><p>求3×4矩阵最大值（函数实现）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
float largest(float a[][4]) { // 列数不可省略
    float max = a[0][0];
    int i, j;
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 4; j++) {
            if (a[i][j] &gt; max) {
                max = a[i][j];
            }
        }
    }
    return max;
}
int main() {
    float a[3][4], max;
    int i, j;
    printf(&quot;请输入3行4列矩阵：\n&quot;);
    for (i = 0; i &lt; 3; i++) {
        for (j = 0; j &lt; 4; j++) {
            scanf(&quot;%f&quot;, &amp;a[i][j]);
        }
    }
    max = largest(a);
    printf(&quot;最大值：%f\n&quot;, max);
    return 0;
}
</code></pre>
            </li>

        </ol>
        <hr />
        <p>&nbsp;</p>
        <h4>5.4 字符数组</h4>
        <p>字符数组用于存储字符或字符串，字符串以<code>&#39;\0&#39;</code>（ASCII码0）作为结束标志。</p>
        <h5>5.4.1 定义格式</h5>
        <pre><code class='language-c' lang='c'>char 数组名[长度]; // 一维字符数组
char 数组名[行数][列数]; // 二维字符数组（存储多个字符串）
</code></pre>
        <ul>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>char str[20];      // 存储单个字符串（最多19个有效字符+1个&#39;\0&#39;）
char name[30][20]; // 存储30个字符串，每个字符串最多19个字符
</code></pre>
            </li>

        </ul>
        <h5>5.4.2 初始化方式</h5>
        <ol>
            <li><p>逐个字符初始化（无<code>&#39;\0&#39;</code>，需手动添加）</p>
                <pre><code class='language-c' lang='c'>char str[4] = {&#39;w&#39;, &#39;e&#39;, &#39;i&#39;, &#39;j&#39;}; // 无结束符，不是字符串
char str[5] = {&#39;G&#39;, &#39;o&#39;, &#39;o&#39;, &#39;d&#39;, &#39;\0&#39;}; // 手动添加结束符
</code></pre>
            </li>
            <li><p>字符串常量初始化（自动添加<code>&#39;\0&#39;</code>）</p>
                <pre><code class='language-c' lang='c'>char str[] = &quot;Good&quot;; // 长度自动为5（4个有效字符+1个&#39;\0&#39;）
char str[8] = &quot;welcome&quot;; // 等价于{&#39;w&#39;,&#39;e&#39;,&#39;l&#39;,&#39;c&#39;,&#39;o&#39;,&#39;m&#39;,&#39;e&#39;,&#39;\0&#39;}
</code></pre>
            </li>

        </ol>
        <h5>5.4.3 字符串的输入输出</h5>
        <ol>
            <li><p>逐个字符读写（用<code>%c</code>）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    char a[3];
    int i;
    // 输入
    for (i = 0; i &lt; 3; i++) {
        scanf(&quot;%c&quot;, &amp;a[i]);
    }
    // 输出
    for (i = 0; i &lt; 3; i++) {
        printf(&quot;%c&quot;, a[i]);
    }
    return 0;
}
</code></pre>
            </li>
            <li><p>整体读写（用<code>%s</code>，自动识别<code>&#39;\0&#39;</code>）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    char c[10];
    scanf(&quot;%s&quot;, c); // 输入时遇空格、换行结束，无需&amp;（数组名是地址）
    printf(&quot;%s&quot;, c); // 输出时遇&#39;\0&#39;结束
    return 0;
}
</code></pre>
            </li>

        </ol>
        <ul>
            <li>注意：<code>scanf(&quot;%s&quot;)</code>无法读取带空格的字符串，需用<code>fgets</code>或<code>scanf(&quot;%[^\n]&quot;, str)</code>。</li>

        </ul>
        <h5>5.4.4 常用字符串处理函数（需包含<code>&lt;string.h&gt;</code>）</h5>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>函数名</th><th>功能描述</th><th>示例</th></tr></thead>
            <tbody><tr><td><code>strlen(s)</code></td><td>求字符串长度（不含<code>&#39;\0&#39;</code>）</td><td><code>strlen(&quot;Good&quot;) → 4</code></td></tr><tr><td><code>strcpy(s1,s2)</code></td><td>将s2复制到s1（s1需足够大）</td><td><code>strcpy(str1, &quot;Hello&quot;)</code></td></tr><tr><td><code>strcmp(s1,s2)</code></td><td>比较s1和s2（ASCII码顺序），返回0（相等）、正数（s1大）、负数（s2大）</td><td><code>strcmp(&quot;abc&quot;, &quot;abd&quot;) → -1</code></td></tr><tr><td><code>strcat(s1,s2)</code></td><td>将s2连接到s1末尾（s1需足够大）</td><td><code>strcat(str1, &quot;World&quot;)</code></td></tr><tr><td><code>strlwr(s)</code></td><td>将s中大写字母转为小写</td><td><code>strlwr(&quot;ABC&quot;) → &quot;abc&quot;</code></td></tr><tr><td><code>strupr(s)</code></td><td>将s中小写字母转为大写</td><td><code>strupr(&quot;abc&quot;) → &quot;ABC&quot;</code></td></tr></tbody>
        </table></figure>
        <ul>
            <li><p>示例：字符串比较与连接</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main() {
    char str1[20] = &quot;Hello&quot;, str2[10] = &quot;World&quot;;
    printf(&quot;长度：%d\n&quot;, strlen(str1)); // 输出5
    strcat(str1, str2);
    printf(&quot;连接后：%s\n&quot;, str1); // 输出HelloWorld
    if (strcmp(str1, &quot;HelloWorld&quot;) == 0) {
        printf(&quot;相等\n&quot;);
    }
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>5.4.5 应用举例：统计字符串中字母、数字、空格个数</h5>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main() {
    char str[80];
    int letter = 0, digit = 0, blank = 0, others = 0, i;
    printf(&quot;请输入一行字符：\n&quot;);
    gets(str); // 读取带空格的字符串（或用fgets(str,80,stdin)）
    for (i = 0; str[i] != &#39;\0&#39;; i++) {
        if ((str[i] &gt;= &#39;A&#39; &amp;&amp; str[i] &lt;= &#39;Z&#39;) || (str[i] &gt;= &#39;a&#39; &amp;&amp; str[i] &lt;= &#39;z&#39;)) {
            letter++;
        } else if (str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;) {
            digit++;
        } else if (str[i] == &#39; &#39;) {
            blank++;
        } else {
            others++;
        }
    }
    printf(&quot;字母：%d，数字：%d，空格：%d，其他：%d\n&quot;, letter, digit, blank, others);
    return 0;
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>5.5 结构体类型</h4>
        <p>结构体用于封装不同类型的数据（如学生信息：学号、姓名、成绩），形成一个整体。</p>
        <h5>5.5.1 结构体类型定义</h5>
        <p>三种定义方式：</p>
        <ol>
            <li><p>先定义类型，再定义变量</p>
                <pre><code class='language-c' lang='c'>struct student { // 结构体类型名：student
    char number[10]; // 学号
    char name[20];   // 姓名
    char sex;        // 性别
    int age;         // 年龄
    float score[20]; // 成绩
    char addr[30];   // 地址
};
struct student stud1, stud2; // 定义结构体变量stud1、stud2
</code></pre>
            </li>
            <li><p>定义类型的同时定义变量</p>
                <pre><code class='language-c' lang='c'>struct student {
    char number[10];
    char name[20];
    char sex;
    int age;
    float score[20];
    char addr[30];
} stud1, stud2; // 直接定义变量
</code></pre>
            </li>
            <li><p>无名结构体（仅能定义一次变量）</p>
                <pre><code class='language-c' lang='c'>struct {
    char number[10];
    char name[20];
    char sex;
    int age;
    float score[20];
    char addr[30];
} stud1, stud2; // 无类型名，后续无法再定义该类型变量
</code></pre>
            </li>

        </ol>
        <h5>5.5.2 结构体变量初始化</h5>
        <p>按成员顺序赋值，字符串需用<code>&quot;&quot;</code>，数值直接赋值：</p>
        <pre><code class='language-c' lang='c'>struct student {
    char number[10];
    char name[20];
    char sex;
    int age;
    float score;
} st1 = {&quot;9708&quot;, &quot;Liwei&quot;, &#39;F&#39;, 20, 95.5}; // 初始化
</code></pre>
        <h5>5.5.3 结构体成员引用</h5>
        <ul>
            <li><p>格式：<code>结构体变量名.成员名</code>（普通变量）、<code>结构体指针-&gt;成员名</code>（指针变量）</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
struct student {
    char name[20];
    int age;
    float score;
} st1 = {&quot;Zhang San&quot;, 20, 89.0}, *p = &amp;st1; // 指针p指向st1
int main() {
    printf(&quot;姓名：%s\n&quot;, st1.name);    // 直接引用：.
    printf(&quot;年龄：%d\n&quot;, p-&gt;age);     // 指针引用：-&gt;
    printf(&quot;成绩：%f\n&quot;, (*p).score); // 等价于p-&gt;score
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>5.5.4 结构体数组</h5>
        <p>用于存储多个结构体变量（如多个学生信息）：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
struct student {
    long num;
    char name[20];
    float score;
} stud[3] = {
    {9701, &quot;Li Ming&quot;, 98.0},
    {9702, &quot;Wang Dan&quot;, 95.0},
    {9703, &quot;Li Hui&quot;, 80.0}
};
int main() {
    int i;
    for (i = 0; i &lt; 3; i++) {
        printf(&quot;学号：%ld，姓名：%s，成绩：%f\n&quot;, stud[i].num, stud[i].name, stud[i].score);
    }
    return 0;
}
</code></pre>
        <h5>5.5.5 应用举例：结构体作为函数参数（求学生成绩平均分）</h5>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#define N 3
struct Score {
    char name[20];
    double chin, math, eng;
    double mean;
};
// 计算平均分
void getMean(struct Score *p) {
    p-&gt;mean = (p-&gt;chin + p-&gt;math + p-&gt;eng) / 3;
}
int main() {
    struct Score stu[N];
    int i;
    // 输入成绩
    for (i = 0; i &lt; N; i++) {
        printf(&quot;请输入第%d个学生信息（姓名 语文 数学 英语）：\n&quot;, i+1);
        scanf(&quot;%s %lf %lf %lf&quot;, stu[i].name, &amp;stu[i].chin, &amp;stu[i].math, &amp;stu[i].eng);
        getMean(&amp;stu[i]);
    }
    // 输出平均分≥80的学生
    printf(&quot;平均分≥80的学生：\n&quot;);
    for (i = 0; i &lt; N; i++) {
        if (stu[i].mean &gt;= 80) {
            printf(&quot;%s：%.2f\n&quot;, stu[i].name, stu[i].mean);
        }
    }
    return 0;
}
</code></pre>
        <p>&nbsp;</p>
        <h3>Chap6 指针</h3>
        <p>核心结论：本章聚焦C语言指针的核心概念与应用，涵盖指针变量的定义、初始化、算术运算，指针与数组、字符串、函数、结构体的关联，以及多级指针、动态内存分配等核心知识点，是实现高效内存操作、模块化编程的关键技术，也是C语言的核心难点与重点。</p>
        <h4>6.1 指针概述</h4>
        <p>指针是指向内存单元的变量，其核心价值在于直接操作内存地址，提高程序执行效率、灵活处理数组与结构体等复杂数据类型。</p>
        <h5>核心概念</h5>
        <ul>
            <li>内存地址：内存中每个字节的唯一编号（如0x0012FF7C），用于标识数据存储位置。</li>
            <li>指针变量：存储内存地址的变量，通过该地址可间接访问对应内存中的数据。</li>
            <li>指针与数据的关系：指针变量存储数据的地址，解引用操作（<code>*</code>）可通过地址获取/修改数据。</li>

        </ul>
        <h5>指针的作用</h5>
        <ul>
            <li>直接操作内存，提高数据访问效率（尤其适用于大数据量场景）。</li>
            <li>灵活处理数组、字符串、结构体等复杂数据类型，简化代码。</li>
            <li>实现函数间的数据双向传递（突破值传递的局限）。</li>
            <li>支持动态内存分配，按需使用内存空间。</li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>6.2 指针变量的定义与使用</h4>
        <p>指针变量的使用需遵循“定义→初始化→引用”的流程，核心是掌握指针的定义格式、地址操作与解引用。</p>
        <h5>6.2.1 指针变量的定义</h5>
        <p>格式：<code>数据类型 *指针变量名;</code></p>
        <ul>
            <li><p>数据类型：指针指向的目标数据的类型（决定解引用时访问的字节数）。</p>
            </li>
            <li><p><code>*</code>：标识该变量为指针类型。</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>int *p;       // 指向int型数据的指针变量
char *q;      // 指向char型数据的指针变量
double *r;    // 指向double型数据的指针变量
</code></pre>
            </li>

        </ul>
        <h5>6.2.2 指针变量的初始化</h5>
        <p>指针变量需初始化后再使用（避免野指针），初始化方式有3种：</p>
        <ol>
            <li><p>指向已定义变量的地址：</p>
                <pre><code class='language-c' lang='c'>int a = 10;
int *p = &amp;a;  // &amp;a获取变量a的地址，赋值给指针p
</code></pre>
            </li>
            <li><p>指向数组元素：</p>
                <pre><code class='language-c' lang='c'>int arr[5] = {1,2,3,4,5};
int *p = arr; // 数组名arr是首元素地址，等价于&amp;arr[0]
</code></pre>
            </li>
            <li><p>赋值为空指针（避免野指针）：</p>
                <pre><code class='language-c' lang='c'>int *p = NULL; // NULL是系统定义的空指针常量（值为0）
</code></pre>
            </li>

        </ol>
        <h5>6.2.3 指针变量的引用</h5>
        <ul>
            <li><p>解引用运算符（<code>*</code>）：通过指针地址访问对应数据。</p>
            </li>
            <li><p>取地址运算符（<code>&amp;</code>）：获取变量的内存地址。</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int a = 20;
    int *p = &amp;a;  // 初始化指针p，指向a的地址

    printf(&quot;a的地址：%p\n&quot;, &amp;a);   // 输出a的地址，%p用于打印地址
    printf(&quot;p存储的地址：%p\n&quot;, p); // 输出p的值（即a的地址）
    printf(&quot;通过p访问a的值：%d\n&quot;, *p); // 解引用，输出20

    *p = 30; // 通过指针修改a的值
    printf(&quot;修改后a的值：%d\n&quot;, a); // 输出30
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>6.2.4 指针的算术运算</h5>
        <p>指针的算术运算与普通变量不同，运算结果取决于指向的数据类型（步长 = 数据类型字节数）：</p>
        <ol>
            <li>指针自增（<code>p++</code>）/自减（<code>p--</code>）：指向相邻的下一个/上一个同类型数据。</li>
            <li>指针加减整数（<code>p + n</code>/<code>p - n</code>）：指向偏移n个步长的同类型数据。</li>
            <li>指针相减（<code>p1 - p2</code>）：仅适用于指向同一数组的指针，结果为两指针间的元素个数。</li>

        </ol>
        <ul>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int arr[3] = {10,20,30};
    int *p = arr; // p指向arr[0]

    printf(&quot;*p = %d\n&quot;, *p);   // 10（arr[0]）
    p++; // 指向arr[1]，步长4字节（int占4字节）
    printf(&quot;*p = %d\n&quot;, *p);   // 20（arr[1]）
    p += 1; // 指向arr[2]
    printf(&quot;*p = %d\n&quot;, *p);   // 30（arr[2]）

    int *p1 = &amp;arr[0], *p2 = &amp;arr[2];
    printf(&quot;p2 - p1 = %d\n&quot;, p2 - p1); // 2（两指针间有2个元素）
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h5>6.2.5 指针的比较运算</h5>
        <p>指针可进行<code>==</code>、<code>!=</code>、<code>&lt;</code>、<code>&gt;</code>等比较运算，仅适用于指向同一连续内存区域（如同一数组）的指针：</p>
        <pre><code class='language-c' lang='c'>if (p1 == p2) {
    printf(&quot;两指针指向同一地址\n&quot;);
}
if (p1 &lt; p2) {
    printf(&quot;p1指向的地址在p2之前\n&quot;);
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>6.3 指针与数组</h4>
        <p>数组与指针密切相关，数组名本质是指向数组首元素的<strong>指针常量</strong>（不可修改地址），指针可灵活访问数组元素。</p>
        <h5>6.3.1 数组名与指针的关系</h5>
        <ul>
            <li>数组名<code>arr</code>等价于<code>&amp;arr[0]</code>（首元素地址），是指针常量（不能进行<code>arr++</code>等修改地址的操作）。</li>
            <li>指针变量可指向数组首元素，通过指针运算访问任意元素。</li>
            <li>核心等价关系：<code>arr[i]</code> ≡ <code>*(arr + i)</code> ≡ <code>*(p + i)</code> ≡ <code>p[i]</code>（p为指向数组首元素的指针变量）。</li>

        </ul>
        <h5>6.3.2 指针访问数组元素</h5>
        <p>两种方式：下标法（<code>p[i]</code>）和指针法（<code>*(p + i)</code>），示例：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int arr[5] = {1,2,3,4,5};
    int *p = arr; // 指针指向数组首元素

    // 指针法访问
    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;%d &quot;, *(p + i)); // 输出1 2 3 4 5
    }
    printf(&quot;\n&quot;);

    // 下标法访问（指针变量支持下标运算）
    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;%d &quot;, p[i]); // 输出1 2 3 4 5
    }
    return 0;
}
</code></pre>
        <h5>6.3.3 指针与二维数组</h5>
        <p>二维数组本质是“数组的数组”，数组名<code>arr</code>是指向首行（一维数组）的指针（行指针）。</p>
        <ul>
            <li><p>核心关系：</p>
                <ul>
                    <li><code>arr</code> ≡ <code>&amp;arr[0]</code>（首行地址，行指针）。</li>
                    <li><code>arr[i]</code> ≡ <code>*(arr + i)</code>（第i行首元素地址，列指针）。</li>
                    <li><code>arr[i][j]</code> ≡ <code>*(arr[i] + j)</code> ≡ <code>*(*(arr + i) + j)</code>（第i行第j列元素）。</li>

                </ul>
            </li>
            <li><p>示例：</p>
            </li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int arr[2][3] = {{1,2,3}, {4,5,6}};
    int (*p)[3] = arr; // 行指针，指向含3个int元素的一维数组

    // 访问arr[1][2]（值为6）
    printf(&quot;%d\n&quot;, arr[1][2]);
    printf(&quot;%d\n&quot;, *(arr[1] + 2));
    printf(&quot;%d\n&quot;, *(*(arr + 1) + 2));
    printf(&quot;%d\n&quot;, p[1][2]);
    return 0;
}
</code></pre>
        <h5>6.3.4 指针数组</h5>
        <p>指针数组是“元素为指针的数组”，格式：<code>数据类型 *数组名[常量表达式];</code></p>
        <ul>
            <li>用途：存储多个字符串（避免二维字符数组的空间浪费）、多个数组的地址等。</li>
            <li>示例：指针数组存储字符串</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    char *strArr[] = {&quot;Beijing&quot;, &quot;Shanghai&quot;, &quot;Guangzhou&quot;}; // 指针数组，每个元素指向字符串常量
    int n = sizeof(strArr) / sizeof(strArr[0]); // 数组长度3

    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%s\n&quot;, strArr[i]); // 输出每个字符串
    }
    return 0;
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>6.4 指针与字符串</h4>
        <p>字符串的本质是字符数组，指针可更灵活地操作字符串（比数组名更灵活，可修改指向）。</p>
        <h5>6.4.1 指针指向字符串常量</h5>
        <ul>
            <li>格式：<code>char *p = &quot;string&quot;;</code>（p指向字符串首字符地址，字符串常量存储在只读区，不可修改）。</li>
            <li>示例：</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    char *p = &quot;Hello World&quot;;
    printf(&quot;%s\n&quot;, p); // 输出Hello World（printf通过p指向的地址遍历到&#39;\0&#39;）
    printf(&quot;%c\n&quot;, *(p + 6)); // 输出W（访问第7个字符）

    // p[0] = &#39;h&#39;; // 错误：字符串常量不可修改
    return 0;
}
</code></pre>
        <h5>6.4.2 指针操作字符数组（可修改字符串）</h5>
        <ul>
            <li>指针指向字符数组首元素，可通过指针修改数组元素（字符串内容）。</li>
            <li>示例：指针修改字符串</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    char str[] = &quot;Hello&quot;;
    char *p = str;

    // 将字符串改为&quot;Hi&quot;
    *p = &#39;H&#39;;
    *(p + 1) = &#39;i&#39;;
    *(p + 2) = &#39;\0&#39;; // 手动添加结束符

    printf(&quot;%s\n&quot;, str); // 输出Hi
    return 0;
}
</code></pre>
        <h5>6.4.3 指针与字符串处理函数</h5>
        <p>字符串处理函数（如<code>strlen</code>、<code>strcpy</code>、<code>strcmp</code>）的参数本质是字符指针，示例：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
int main() {
    char str1[20], str2[] = &quot;Hello&quot;;
    char *p1 = str1, *p2 = str2;

    strcpy(p1, p2); // 复制p2指向的字符串到p1指向的数组
    printf(&quot;str1: %s\n&quot;, p1); // 输出Hello
    printf(&quot;长度: %d\n&quot;, strlen(p1)); // 输出5（不含&#39;\0&#39;）

    if (strcmp(p1, p2) == 0) {
        printf(&quot;两字符串相等\n&quot;);
    }
    return 0;
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>6.5 指针与函数</h4>
        <p>指针作为函数参数可实现数据双向传递，返回指针的函数可返回动态分配的内存或数组地址。</p>
        <h5>6.5.1 指针作为函数参数</h5>
        <ul>
            <li>普通变量指针：实现函数间数据双向传递（突破值传递局限）。</li>
            <li>数组指针：传递数组时，本质是传递数组首地址（节省内存，提高效率）。</li>
            <li>示例1：指针作为参数交换两数</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}
int main() {
    int a = 10, b = 20;
    swap(&amp;a, &amp;b); // 传递变量地址
    printf(&quot;a = %d, b = %d\n&quot;, a, b); // 输出a=20, b=10
    return 0;
}
</code></pre>
        <ul>
            <li>示例2：指针传递数组（求数组和）</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int sumArr(int *arr, int n) {
    int sum = 0;
    for (int i = 0; i &lt; n; i++) {
        sum += *(arr + i); // 指针访问数组元素
    }
    return sum;
}
int main() {
    int arr[] = {1,2,3,4,5};
    int n = sizeof(arr) / sizeof(arr[0]);
    printf(&quot;数组和：%d\n&quot;, sumArr(arr, n)); // 传递数组名（首地址）
    return 0;
}
</code></pre>
        <h5>6.5.2 返回指针的函数</h5>
        <ul>
            <li>格式：<code>数据类型 *函数名(参数表);</code></li>
            <li>注意：返回的指针不能指向函数内的局部变量（函数调用结束后局部变量内存释放），可返回全局变量、静态变量或动态分配的内存地址。</li>
            <li>示例：返回动态分配的数组地址</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
int *createArr(int n) {
    int *p = (int *)malloc(n * sizeof(int)); // 动态分配内存
    if (p == NULL) {
        printf(&quot;内存分配失败\n&quot;);
        exit(1);
    }
    // 初始化数组
    for (int i = 0; i &lt; n; i++) {
        *(p + i) = i + 1;
    }
    return p;
}
int main() {
    int *arr = createArr(5);
    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;%d &quot;, arr[i]); // 输出1 2 3 4 5
    }
    free(arr); // 释放动态内存
    arr = NULL; // 避免野指针
    return 0;
}
</code></pre>
        <h5>6.5.3 函数指针</h5>
        <ul>
            <li>函数指针是指向函数的指针，存储函数的入口地址。</li>
            <li>格式：<code>返回值类型 (*指针名)(参数类型表);</code></li>
            <li>用途：实现函数的动态调用（如回调函数）。</li>
            <li>示例：函数指针调用函数</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int add(int a, int b) {
    return a + b;
}
int sub(int a, int b) {
    return a - b;
}
int main() {
    int (*funcPtr)(int, int); // 定义函数指针
    funcPtr = add; // 指向add函数
    printf(&quot;3 + 5 = %d\n&quot;, funcPtr(3, 5)); // 调用add，输出8

    funcPtr = sub; // 指向sub函数
    printf(&quot;3 - 5 = %d\n&quot;, funcPtr(3, 5)); // 调用sub，输出-2
    return 0;
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>6.6 指针与结构体</h4>
        <p>结构体指针是指向结构体变量的指针，通过<code>-&gt;</code>运算符访问结构体成员，比直接使用结构体变量更高效（传递地址而非整个结构体）。</p>
        <h5>6.6.1 结构体指针的定义与初始化</h5>
        <ul>
            <li>格式：<code>struct 结构体名 *指针名;</code></li>
            <li>初始化：指针指向结构体变量的地址。</li>
            <li>示例：</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
struct Student {
    char name[20];
    int age;
    float score;
};
int main() {
    struct Student stu = {&quot;Zhang San&quot;, 20, 90.5};
    struct Student *p = &amp;stu; // 结构体指针指向stu

    // 访问结构体成员：两种方式
    printf(&quot;姓名：%s\n&quot;, (*p).name); // (*p)等价于stu，用.访问
    printf(&quot;年龄：%d\n&quot;, p-&gt;age);   // 结构体指针用-&gt;访问（推荐）
    printf(&quot;成绩：%f\n&quot;, p-&gt;score);
    return 0;
}
</code></pre>
        <h5>6.6.2 结构体指针作为函数参数</h5>
        <ul>
            <li>传递结构体指针，避免结构体变量的拷贝（节省内存），可修改结构体内容。</li>
            <li>示例：</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
struct Student {
    char name[20];
    int age;
};
void updateAge(struct Student *p, int newAge) {
    p-&gt;age = newAge; // 修改结构体成员
}
int main() {
    struct Student stu = {&quot;Li Si&quot;, 19};
    updateAge(&amp;stu, 20);
    printf(&quot;修改后年龄：%d\n&quot;, stu.age); // 输出20
    return 0;
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>6.7 多级指针</h4>
        <p>多级指针是指向指针的指针，常用于处理指针数组、二维数组指针等场景，最常用的是二级指针。</p>
        <h5>6.7.1 二级指针的定义与使用</h5>
        <ul>
            <li>格式：<code>数据类型 **指针名;</code>（**表示二级指针）</li>
            <li>核心关系：<code>**p</code> 访问最终指向的数据。</li>
            <li>示例：</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main() {
    int a = 10;
    int *p = &amp;a; // 一级指针，指向a
    int **pp = &amp;p; // 二级指针，指向p

    printf(&quot;a的地址：%p\n&quot;, &amp;a);
    printf(&quot;p存储的地址：%p\n&quot;, p);
    printf(&quot;pp存储的地址：%p\n&quot;, pp);
    printf(&quot;通过pp访问a：%d\n&quot;, **pp); // 输出10

    **pp = 20; // 通过二级指针修改a的值
    printf(&quot;修改后a：%d\n&quot;, a); // 输出20
    return 0;
}
</code></pre>
        <h5>6.7.2 二级指针与指针数组</h5>
        <p>二级指针常用于处理指针数组（如传递多个字符串），示例：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void printStrings(char **strArr, int n) {
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%s\n&quot;, *(strArr + i)); // 二级指针访问指针数组元素
    }
}
int main() {
    char *strArr[] = {&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;};
    int n = sizeof(strArr) / sizeof(strArr[0]);
    printStrings(strArr, n); // 指针数组名是二级指针（指向指针的指针）
    return 0;
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>6.8 指针应用举例</h4>
        <h5>6.8.1 动态内存分配（malloc/free）</h5>
        <ul>
            <li><code>malloc</code>：动态分配指定字节数的内存，返回void*指针（需强制类型转换）。</li>
            <li><code>free</code>：释放动态分配的内存，避免内存泄漏。</li>
            <li>示例：动态分配结构体数组</li>

        </ul>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
struct Book {
    char title[50];
    float price;
};
int main() {
    int n;
    printf(&quot;请输入图书数量：&quot;);
    scanf(&quot;%d&quot;, &amp;n);

    // 动态分配n个Book结构体的内存
    struct Book *books = (struct Book *)malloc(n * sizeof(struct Book));
    if (books == NULL) {
        printf(&quot;内存分配失败\n&quot;);
        return 1;
    }

    // 输入图书信息
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;请输入第%d本书的标题和价格：&quot;, i+1);
        scanf(&quot;%s %f&quot;, books[i].title, &amp;books[i].price);
    }

    // 输出图书信息
    printf(&quot;\n图书列表：\n&quot;);
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;标题：%s，价格：%.2f\n&quot;, (books + i)-&gt;title, (books + i)-&gt;price);
    }

    free(books); // 释放内存
    books = NULL; // 避免野指针
    return 0;
}
</code></pre>
        <h5>6.8.2 指针实现字符串反转</h5>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void reverseStr(char *str) {
    char *left = str;
    char *right = str + strlen(str) - 1; // 指向字符串末尾（不含&#39;\0&#39;）
    char temp;

    while (left &lt; right) {
        // 交换左右指针指向的字符
        temp = *left;
        *left = *right;
        *right = temp;
        left++;
        right--;
    }
}
int main() {
    char str[] = &quot;Hello World&quot;;
    reverseStr(str);
    printf(&quot;反转后：%s\n&quot;, str); // 输出dlroW olleH
    return 0;
}
</code></pre>
        <h5>6.8.3 指针实现冒泡排序</h5>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void bubbleSort(int *arr, int n) {
    for (int i = 0; i &lt; n-1; i++) {
        for (int j = 0; j &lt; n-i-1; j++) {
            if (*(arr + j) &gt; *(arr + j+1)) {
                // 交换相邻元素
                int temp = *(arr + j);
                *(arr + j) = *(arr + j+1);
                *(arr + j+1) = temp;
            }
        }
    }
}
int main() {
    int arr[] = {5,2,9,1,5,6};
    int n = sizeof(arr) / sizeof(arr[0]);
    bubbleSort(arr, n);

    printf(&quot;排序后：&quot;);
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%d &quot;, arr[i]); // 输出1 2 5 5 6 9
    }
    return 0;
}
</code></pre>
        <p>&nbsp;</p>
        <h3>Chap7 字符数组</h3>
        <p>核心结论：本章聚焦C语言字符数组与字符串的核心应用，涵盖字符数组的定义、初始化、输入输出，字符串与指针的关联，常用字符串处理函数的使用，以及字符数组、指针作为函数参数的实战场景，是处理文本数据、实现字符串操作的核心知识点，也是模块化编程中传递文本数据的关键技术。</p>
        <h4>7.1 字符数组</h4>
        <p>字符数组是存储字符数据的构造类型，核心用于存放字符串（以<code>&#39;\0&#39;</code>结尾的字符序列），其使用需掌握定义、初始化、输入输出及字符串处理函数的核心规则。</p>
        <h5>7.1.1 字符数组的定义</h5>
        <p>格式：<code>char 数组名[字符元素个数];</code></p>
        <ul>
            <li><p>数组名：符合标识符规则，代表字符数组的首地址（地址常量）。</p>
            </li>
            <li><p>字符元素个数：指定数组可存储的最大字符数（包含<code>&#39;\0&#39;</code>）。</p>
            </li>
            <li><p>示例：</p>
                <pre><code class='language-c' lang='c'>char str[20]; // 定义可存储20个字符的字符数组
char msg[10]; // 定义可存储10个字符的字符数组
</code></pre>
            </li>

        </ul>
        <h5>7.1.2 字符数组的初始化</h5>
        <p>两种核心方式，初始化时需注意<code>&#39;\0&#39;</code>的自动添加规则：</p>
        <ol>
            <li><p>逐个字符赋值：</p>
                <pre><code class='language-c' lang='c'>char str[4] = {&#39;w&#39;, &#39;e&#39;, &#39;i&#39;, &#39;j&#39;}; // 数组长度4，无自动添加&#39;\0&#39;
char str2[5] = {&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;}; // 无&#39;\0&#39;，非字符串形式
</code></pre>
            </li>
            <li><p>字符串直接赋值（推荐）：</p>
                <pre><code class='language-c' lang='c'>char str[] = &quot;good morning&quot;; // 自动在末尾添加&#39;\0&#39;，数组长度=字符串长度+1
char str2[8] = &quot;welcome&quot;; // 等价于{&#39;w&#39;,&#39;e&#39;,&#39;l&#39;,&#39;c&#39;,&#39;o&#39;,&#39;m&#39;,&#39;e&#39;,&#39;\0&#39;}
</code></pre>
            </li>

        </ol>
        <ul>
            <li>关键说明：字符串形式初始化会自动添加<code>&#39;\0&#39;</code>（字符串结束标志），数组长度默认包含该结束符；逐个字符赋值需手动添加<code>&#39;\0&#39;</code>才能作为字符串使用。</li>

        </ul>
        <h5>7.1.3 用字符数组存放字符串</h5>
        <ul>
            <li>字符串本质：以<code>&#39;\0&#39;</code>（ASCII码值0）结尾的字符序列，系统通过<code>&#39;\0&#39;</code>判断字符串结束。</li>
            <li>存储示例：<code>char ch[] = &quot;Good&quot;;</code> 存储结构为 <code>G o o d \0</code>，数组长度为5（而非4）。</li>
            <li>字符串长度：有效字符个数（不含<code>&#39;\0&#39;</code>），需通过<code>strlen</code>函数获取。</li>

        </ul>
        <h5>7.1.4 字符数组的输入输出</h5>
        <p>支持逐个字符和整体（字符串）两种方式，需注意输入时的分隔符和结束标志：</p>
        <ol>
            <li><p>逐个字符输入输出：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char a[3];
    int i;
    // 输入
    for (i = 0; i &lt; 3; i++)
        scanf(&quot;%c&quot;, &amp;a[i]);
    // 输出
    for (i = 0; i &lt; 3; i++)
        printf(&quot;%c&quot;, a[i]);
}
</code></pre>
                <ul>
                    <li>说明：空格、回车会被当作输入字符，需注意输入格式。</li>

                </ul>
            </li>
            <li><p>整体输入输出（字符串形式）：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char c[4];
    // 输入：遇空格、回车结束，自动添加&#39;\0&#39;
    scanf(&quot;%s&quot;, c);
    // 输出：遇&#39;\0&#39;结束，无需地址符&amp;（数组名即首地址）
    printf(&quot;%s&quot;, c);
}
</code></pre>
                <ul>
                    <li><p>关键问题：<code>scanf(&quot;%s&quot;)</code> 无法读取带空格的字符串，解决方案：</p>
                        <ul>
                            <li><p>使用<code>gets</code>函数（不推荐，存在缓冲区溢出风险）：</p>
                                <pre><code class='language-c' lang='c'>char str[13];
gets(str); // 可读取带空格的字符串，回车结束
</code></pre>
                            </li>
                            <li><p>使用<code>fgets</code>函数（推荐，限制字符数）：</p>
                                <pre><code class='language-c' lang='c'>char name[20];
fgets(name, 20, stdin); // 最多读19个字符，保留换行符，自动加&#39;\0&#39;
</code></pre>
                            </li>
                            <li><p>使用<code>scanf(&quot;%[^\n]&quot;, str)</code>：</p>
                                <pre><code class='language-c' lang='c'>char str[13];
scanf(&quot;%[^\n]&quot;, str); // 遇回车结束，可读取带空格的字符串
</code></pre>
                            </li>

                        </ul>
                    </li>

                </ul>
            </li>

        </ol>
        <h5>7.1.5 字符串处理标准函数</h5>
        <p>需包含头文件<code>#include &lt;string.h&gt;</code>（<code>puts</code>、<code>gets</code>除外），核心函数如下：</p>
        <ol>
            <li><p>字符串输出函数<code>puts()</code></p>
                <ul>
                    <li><p>格式：<code>puts(字符数组名/字符串常量)</code></p>
                    </li>
                    <li><p>功能：输出字符串至终端，遇<code>&#39;\0&#39;</code>结束，并自动换行（将<code>&#39;\0&#39;</code>转为<code>&#39;\n&#39;</code>）。</p>
                    </li>
                    <li><p>示例：</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char c[] = &quot;BASIC\ndBASE&quot;;
    puts(c); // 可识别转义字符，输出时换行
}
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p>字符串输入函数<code>gets()</code>（已淘汰）</p>
                <ul>
                    <li>格式：<code>gets(字符数组名)</code></li>
                    <li>功能：从终端读字符串至字符数组，回车结束，自动将<code>&#39;\n&#39;</code>转为<code>&#39;\0&#39;</code>。</li>
                    <li>缺陷：无缓冲区大小检测，易导致内存溢出，推荐用<code>fgets</code>替代。</li>

                </ul>
            </li>
            <li><p>字符串长度函数<code>strlen()</code></p>
                <ul>
                    <li><p>格式：<code>strlen(字符数组名/字符串常量)</code></p>
                    </li>
                    <li><p>功能：返回字符串有效字符个数（不含<code>&#39;\0&#39;</code>）。</p>
                    </li>
                    <li><p>示例：</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void main() {
    char ch[20] = &quot;12$%ert \619\0pop&quot;;
    printf(&quot;长度：%d\n&quot;, strlen(ch)); // 输出10（&#39;\0&#39;前的有效字符）
    puts(ch); // 输出12$%ert 19（\61是&#39;1&#39;的八进制ASCII码）
}
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p>字符串复制函数<code>strcpy()</code></p>
                <ul>
                    <li><p>格式：<code>strcpy(目标字符数组, 源字符串)</code></p>
                    </li>
                    <li><p>功能：将源字符串（含<code>&#39;\0&#39;</code>）复制到目标字符数组，目标数组需足够大。</p>
                    </li>
                    <li><p>示例：</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void main() {
    char st1[15], st2[] = &quot;C Language&quot;;
    strcpy(st1, st2);
    puts(st1); // 输出C Language
}
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p>字符串比较函数<code>strcmp()</code></p>
                <ul>
                    <li><p>格式：<code>strcmp(字符串1, 字符串2)</code></p>
                    </li>
                    <li><p>功能：按ASCII码逐字符比较，返回值：</p>
                        <ul>
                            <li>0：两字符串相等；</li>
                            <li>正数：字符串1 &gt; 字符串2；</li>
                            <li>负数：字符串1 &lt; 字符串2。</li>

                        </ul>
                    </li>
                    <li><p>注意：不可用<code>==</code>直接比较字符串，需用该函数。</p>
                    </li>
                    <li><p>示例：</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void main() {
    char str1[] = &quot;abc&quot;, str2[] = &quot;abd&quot;;
    if (strcmp(str1, str2) &lt; 0)
        printf(&quot;str1 &lt; str2\n&quot;); // 输出该结果
}
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p>字符串大小写转换函数</p>
                <ul>
                    <li><p><code>strlwr(字符数组)</code>：将大写字母转为小写；</p>
                    </li>
                    <li><p><code>strupr(字符数组)</code>：将小写字母转为大写。</p>
                    </li>
                    <li><p>示例：</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void main() {
    char str[] = &quot;Hello World&quot;;
    strlwr(str);
    printf(&quot;%s\n&quot;, str); // 输出hello world
    strupr(str);
    printf(&quot;%s\n&quot;, str); // 输出HELLO WORLD
}
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p>字符串连接函数<code>strcat()</code></p>
                <ul>
                    <li><p>格式：<code>strcat(目标字符数组, 源字符串)</code></p>
                    </li>
                    <li><p>功能：将源字符串连接到目标字符串末尾，目标数组需足够大（覆盖目标字符串的<code>&#39;\0&#39;</code>）。</p>
                    </li>
                    <li><p>示例：</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void main() {
    char ch1[20] = &quot;aaa&quot;, ch2[20] = &quot;bbbb&quot;;
    strcat(ch1, ch2);
    printf(&quot;%s\n&quot;, ch1); // 输出aaabbbb
}
</code></pre>
                    </li>

                </ul>
            </li>

        </ol>
        <hr />
        <p>&nbsp;</p>
        <h4>7.2 字符串与指针</h4>
        <p>C语言中字符串可通过字符数组或字符指针两种方式表示，指针操作字符串更灵活，但需注意字符串常量的只读特性。</p>
        <h5>7.2.1 字符串的两种表示形式</h5>
        <ol>
            <li><p>字符数组形式：</p>
                <pre><code class='language-c' lang='c'>char str[] = &quot;programming&quot;; // 数组名是首地址（常量），可修改数组元素
</code></pre>
                <ul>
                    <li>特点：字符串存储在栈区，可修改字符内容；数组长度=字符串长度+1（含<code>&#39;\0&#39;</code>）。</li>

                </ul>
            </li>
            <li><p>字符指针形式：</p>
                <pre><code class='language-c' lang='c'>char *pstr = &quot;programming&quot;; // 指针指向字符串常量（只读区）
// 或分步赋值
char *pstr;
pstr = &quot;programming&quot;;
</code></pre>
                <ul>
                    <li>特点：指针是变量，可重新赋值指向其他字符串；字符串常量存储在只读区，不可修改字符内容。</li>

                </ul>
            </li>

        </ol>
        <h5>7.2.2 两种表示形式的核心区别</h5>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>特性</th><th>字符数组（<code>char str[]</code>）</th><th>字符指针（<code>char *pstr</code>）</th></tr></thead>
            <tbody><tr><td>存储位置</td><td>栈区（可修改）</td><td>只读数据区（不可修改）</td></tr><tr><td>变量性质</td><td>地址常量（不可赋值）</td><td>指针变量（可重新赋值）</td></tr><tr><td>内存占用</td><td>字符串长度+1字节</td><td>4字节（32位系统）/8字节（64位系统）</td></tr><tr><td>示例操作</td><td><code>str[0] = &#39;P&#39;</code>（合法）</td><td><code>pstr[0] = &#39;P&#39;</code>（非法）</td></tr></tbody>
        </table></figure>
        <h5>7.2.3 指针操作字符串示例</h5>
        <ol>
            <li><p>指针指向字符数组（可修改字符串）：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char str[] = &quot;Hello&quot;;
    char *p = str;
    *p = &#39;H&#39;;          // 修改首字符为&#39;H&#39;
    *(p + 1) = &#39;i&#39;;    // 修改第二个字符为&#39;i&#39;
    *(p + 2) = &#39;\0&#39;;   // 手动添加结束符
    printf(&quot;%s\n&quot;, str); // 输出Hi
}
</code></pre>
            </li>
            <li><p>指针指向字符串常量（不可修改）：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char *p = &quot;Hello World&quot;;
    printf(&quot;%s\n&quot;, p);       // 输出Hello World
    printf(&quot;%c\n&quot;, *(p + 6)); // 输出W
    // p[0] = &#39;h&#39;; // 错误：字符串常量不可修改
}
</code></pre>
            </li>
            <li><p>指针复制字符串：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char a[80], b[80], *pa = a, *pb = b;
    scanf(&quot;%s&quot;, pa);
    while (*pa != &#39;\0&#39;)
        *pb++ = *pa++; // 逐字符复制，指针后移
    *pb = &#39;\0&#39;; // 手动添加结束符
    printf(&quot;%s\n&quot;, b);
}
</code></pre>
            </li>
            <li><p>指针输出字符串部分内容：</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char *s1 = &quot;C language&quot;;
    s1 += 2; // 指针指向第3个字符（&#39;l&#39;）
    printf(&quot;%s\n&quot;, s1); // 输出language
}
</code></pre>
            </li>

        </ol>
        <hr />
        <p>&nbsp;</p>
        <h4>7.3 字符数组、指针作为函数参数</h4>
        <p>字符数组名或字符指针可作为函数参数，实现字符串的传递与处理，核心是利用地址传递特性，避免字符串拷贝，提高效率。</p>
        <h5>7.3.1 字符数组作为函数参数</h5>
        <p>示例1：字符串反序（字符数组参数）</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void fanxu(char chuan[]) {
    int i = 0, n = strlen(chuan);
    char med;
    for (i = 0; i &lt; n / 2; i++) {
        med = chuan[i];
        chuan[i] = chuan[n - i - 1];
        chuan[n - i - 1] = med;
    }
}
void main() {
    char ch[20];
    printf(&quot;请输入一个字符串（长度不超过20）：\n&quot;);
    fgets(ch, 20, stdin);
    printf(&quot;原始字符串：\n&quot;);
    puts(ch);
    fanxu(ch);
    printf(&quot;反序后字符串：\n&quot;);
    puts(ch);
}
</code></pre>
        <p>示例2：统计字符个数（字符数组参数）</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char str[80];
    int letter = 0, digit = 0, blank = 0, others = 0, i;
    printf(&quot;请输入一行字符：\n&quot;);
    gets(str);
    for (i = 0; str[i] != &#39;\0&#39;; i++) {
        if ((str[i] &gt;= &#39;A&#39; &amp;&amp; str[i] &lt;= &#39;Z&#39;) || (str[i] &gt;= &#39;a&#39; &amp;&amp; str[i] &lt;= &#39;z&#39;))
            letter++;
        else if (str[i] &gt;= &#39;0&#39; &amp;&amp; str[i] &lt;= &#39;9&#39;)
            digit++;
        else if (str[i] == &#39; &#39;)
            blank++;
        else
            others++;
    }
    printf(&quot;字母：%d，数字：%d，空格：%d，其他：%d\n&quot;, letter, digit, blank, others);
}
</code></pre>
        <h5>7.3.2 字符指针作为函数参数</h5>
        <p>示例1：字符串反序（指针参数）</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
void fanxu(char *m) {
    int n = strlen(m);
    char med, *p = m, *q = m + n - 1;
    for (; p &lt; m + n / 2; p++, q--) {
        med = *p;
        *p = *q;
        *q = med;
    }
}
void main() {
    char ch[20];
    printf(&quot;请输入一个字符串（长度不超过20）：\n&quot;);
    gets(ch);
    printf(&quot;原始字符串：\n&quot;);
    puts(ch);
    fanxu(ch);
    printf(&quot;反序后字符串：\n&quot;);
    puts(ch);
}
</code></pre>
        <p>示例2：删除指定字符（指针参数）</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void del_ch(char *p, char ch) {
    char *q = p;
    for (; *p != &#39;\0&#39;; p++) {
        if (*p != ch) {
            *q = *p;
            q++;
        }
    }
    *q = &#39;\0&#39;; // 手动添加结束符
}
void main() {
    char str[80], *pt, ch;
    printf(&quot;请输入一个字符串：\n&quot;);
    gets(str);
    pt = str;
    printf(&quot;请输入要删除的字符：\n&quot;);
    ch = getchar();
    del_ch(pt, ch);
    printf(&quot;新字符串：\n%s\n&quot;, str);
}
</code></pre>
        <p>示例3：字符串复制（指针参数）</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void strcopy(char *from, char *to) {
    while (*from != &#39;\0&#39;)
        *(to++) = *(from++);
    *to = &#39;\0&#39;;
}
void main() {
    char a[80], b[80], *pa = a, *pb = b;
    scanf(&quot;%[^\n]&quot;, pa);
    strcopy(pa, pb);
    printf(&quot;%s\n&quot;, pb);
}
</code></pre>
        <p>&nbsp;</p>
        <h3>Chap8 结构体</h3>
        <p>核心结论：本章聚焦C语言结构体的核心应用，涵盖结构体类型的定义、变量初始化与引用，结构体数组的使用，typedef类型别名定义，以及指针与结构体的深度结合（结构体指针、指针作为函数参数），是处理多类型关联数据（如学生信息、商品数据）的核心工具，也是实现复杂数据组织与模块化编程的关键知识点。</p>
        <h4>8.1 结构体类型</h4>
        <p>结构体是由不同类型成员组成的构造数据类型，核心用于描述具有多个关联属性的复杂对象（如学生、商品），其使用需掌握定义、初始化、引用及输入输出的完整流程。</p>
        <h5>8.1.1 结构体概述</h5>
        <ul>
            <li><p>结构体的本质：将多个不同类型的数据（成员）封装为一个整体，描述“属性集合型”数据（如学生包含学号、姓名、成绩等属性）。</p>
            </li>
            <li><p>核心优势：解决单一基本类型无法描述复杂对象的问题，使数据组织更贴近实际场景。</p>
            </li>
            <li><p>结构体的一般格式：</p>
                <pre><code class='language-c' lang='c'>struct 结构体类型名 {
    类型标识符 成员名1;
    类型标识符 成员名2;
    // ... 其他成员
};
</code></pre>
            </li>
            <li><p>示例（学生信息结构体）：</p>
                <pre><code class='language-c' lang='c'>struct student {
    char number[10];  // 学号
    char name[20];    // 姓名
    char sex;         // 性别
    int age;          // 年龄
    float score[20];  // 成绩
    char addr[30];    // 地址
};
</code></pre>
            </li>

        </ul>
        <h5>8.1.2 结构体类型与变量的定义</h5>
        <p>三种核心定义形式，按需选择使用：</p>
        <ol>
            <li><p>形式一：先定义结构体类型，再定义变量</p>
                <pre><code class='language-c' lang='c'>// 先定义类型
struct student {
    char name[20];
    int age;
    float score;
};
// 再定义变量
struct student stud1, stud2;
</code></pre>
            </li>
            <li><p>形式二：定义类型的同时定义变量</p>
                <pre><code class='language-c' lang='c'>struct student {
    char name[20];
    int age;
    float score;
} stud1, stud2;  // 直接定义变量
</code></pre>
            </li>
            <li><p>形式三：无名结构体类型（仅用于一次性变量）</p>
                <pre><code class='language-c' lang='c'>struct {
    char name[20];
    int age;
    float score;
} stud1, stud2;  // 无类型名，无法复用
</code></pre>
            </li>

        </ol>
        <h5>8.1.3 结构体变量的初始化</h5>
        <p>按成员顺序赋值，支持嵌套结构体初始化，未赋值成员自动为0（数值类型）或空（字符类型）：</p>
        <pre><code class='language-c' lang='c'>// 基础初始化
struct stud {
    long num;
    char name[20];
    char sex;
    char addr[30];
} st1 = {9708, &quot;Liwei&quot;, &#39;F&#39;, &quot;44BeijingRoad&quot;};

// 嵌套结构体初始化（日期+人员信息）
struct date {
    int month;
    int day;
    int year;
};
struct person {
    char name[20];
    struct date birthday;
    int age;
} p1 = {&quot;Zhang San&quot;, {10, 1, 2000}, 24};
</code></pre>
        <h5>8.1.4 结构体变量的引用</h5>
        <p>通过“成员运算符（.）”访问成员，嵌套结构体需逐级访问：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    struct student {
        char name[20];
        int age;
        float score;
    } stu = {&quot;Li Si&quot;, 19, 89.5};

    // 访问普通成员
    printf(&quot;姓名：%s\n&quot;, stu.name);
    printf(&quot;年龄：%d\n&quot;, stu.age);
    stu.score = 92.0;  // 修改成员值
    printf(&quot;成绩：%.1f\n&quot;, stu.score);

    // 嵌套结构体访问
    struct date { int m, d, y; };
    struct person {
        char name[20];
        struct date birth;
    } p = {&quot;Wang Wu&quot;, {5, 20, 2001}};
    printf(&quot;生日：%d年%d月%d日\n&quot;, p.birth.y, p.birth.m, p.birth.d);
}
</code></pre>
        <h5>8.1.5 结构体变量的输入输出</h5>
        <p>C语言不支持结构体整体输入输出，需逐个成员操作：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    struct student {
        char name[20];
        int age;
        float score;
    } stu;

    // 输入
    printf(&quot;请输入姓名、年龄、成绩：\n&quot;);
    scanf(&quot;%s %d %f&quot;, stu.name, &amp;stu.age, &amp;stu.score);  // 字符数组无需&amp;

    // 输出
    printf(&quot;姓名：%s\n年龄：%d\n成绩：%.1f\n&quot;, stu.name, stu.age, stu.score);
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>8.2 结构体数组</h4>
        <p>结构体数组是元素为结构体类型的数组，核心用于存储多个同类型复杂对象（如多个学生、多个商品）。</p>
        <h5>8.2.1 结构体数组的定义</h5>
        <p>三种定义形式，与结构体变量定义逻辑一致：</p>
        <ol>
            <li><p>先定义类型，再定义数组</p>
                <pre><code class='language-c' lang='c'>struct student {
    long num;
    char name[20];
    float score;
};
struct student stud[100];  // 100个学生的数组
</code></pre>
            </li>
            <li><p>定义类型同时定义数组</p>
                <pre><code class='language-c' lang='c'>struct student {
    long num;
    char name[20];
    float score;
} stud[100];
</code></pre>
            </li>
            <li><p>无名类型直接定义数组</p>
                <pre><code class='language-c' lang='c'>struct {
    long num;
    char name[20];
    float score;
} stud[100];
</code></pre>
            </li>

        </ol>
        <h5>8.2.2 结构体数组的初始化</h5>
        <p>按数组元素顺序，逐个结构体赋值，支持部分成员初始化：</p>
        <pre><code class='language-c' lang='c'>struct student {
    long num;
    char name[20];
    int age;
    float score;
} stud[3] = {
    {9701, &quot;LiMing&quot;, 20, 98.0},    // 第1个元素
    {9702, &quot;WangDan&quot;, 20, 95.0},   // 第2个元素
    {9703, &quot;LiHui&quot;, 19, 80.0}     // 第3个元素
};
</code></pre>
        <h5>8.2.3 结构体数组的引用与输入输出</h5>
        <p>通过“数组下标+成员运算符”访问元素成员，输入输出需遍历数组：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    struct student {
        long num;
        char name[20];
        float score;
    } stud[3] = {
        {9701, &quot;LiMing&quot;, 98.0},
        {9702, &quot;WangDan&quot;, 95.0},
        {9703, &quot;LiHui&quot;, 80.0}
    };

    // 输出所有学生信息
    for (int i = 0; i &lt; 3; i++) {
        printf(&quot;学号：%ld，姓名：%s，成绩：%.1f\n&quot;,
               stud[i].num, stud[i].name, stud[i].score);
    }

    // 输入新学生信息
    struct student new_stud[2];
    for (int i = 0; i &lt; 2; i++) {
        printf(&quot;请输入第%d个学生的学号、姓名、成绩：\n&quot;, i+1);
        scanf(&quot;%ld %s %f&quot;, &amp;new_stud[i].num, new_stud[i].name, &amp;new_stud[i].score);
    }
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>8.3 定义类型（typedef）</h4>
        <p>typedef用于为已有类型定义别名，简化复杂类型描述（如结构体、数组、指针），提升代码可读性和可移植性。</p>
        <h5>8.3.1 typedef的基本格式</h5>
        <pre><code class='language-c' lang='c'>typedef 原类型 新类型名;
</code></pre>
        <h5>8.3.2 常见应用场景</h5>
        <ol>
            <li><p>基本类型别名</p>
                <pre><code class='language-c' lang='c'>typedef unsigned long int ULI;
ULI x = 123456789;  // 等价于 unsigned long int x;
</code></pre>
            </li>
            <li><p>数组类型别名</p>
                <pre><code class='language-c' lang='c'>typedef double VECT4[4];  // 定义“4个double元素的数组”类型
VECT4 v1, v2;  // 等价于 double v1[4], v2[4];

typedef double MAT[5][5];  // 5×5双精度数组类型
MAT a1, a2;  // 等价于 double a1[5][5], a2[5][5];
</code></pre>
            </li>
            <li><p>指针类型别名</p>
                <pre><code class='language-c' lang='c'>typedef int *IP;
IP p1, p2;  // 等价于 int *p1, *p2;（注意：不同于#define MIP int *，后者会导致p2为int类型）
</code></pre>
            </li>
            <li><p>结构体类型别名（最常用）</p>
                <pre><code class='language-c' lang='c'>// 方式1：先定义结构体，再typedef
struct student {
    char name[20];
    int age;
};
typedef struct student SD;

// 方式2：定义结构体同时typedef
typedef struct student {
    char name[20];
    int age;
} SD;

// 方式3：无名结构体typedef
typedef struct {
    char name[20];
    int age;
} SD;

SD stu1, stu2;  // 简化结构体变量定义，无需写struct
</code></pre>
            </li>

        </ol>
        <h5>8.3.3 typedef与#define的区别</h5>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>特性</th><th>typedef</th><th>#define</th></tr></thead>
            <tbody><tr><td>本质</td><td>类型别名定义（编译阶段处理）</td><td>文本替换（预处理阶段处理）</td></tr><tr><td>作用范围</td><td>局部或全局（遵循作用域规则）</td><td>全局（从定义处到文件结束）</td></tr><tr><td>指针类型处理</td><td>可正确定义多个指针</td><td>可能导致错误（如#define MIP int *; MIP p1,p2; 中p2为int类型）</td></tr><tr><td>数组类型处理</td><td>可定义数组类型别名</td><td>仅文本替换，无法定义数组类型</td></tr></tbody>
        </table></figure>
        <hr />
        <p>&nbsp;</p>
        <h4>8.4 指针与结构体</h4>
        <p>结构体指针是指向结构体变量/数组的指针，通过“指向运算符（-&gt;）”访问成员，比直接使用结构体变量更高效（传递地址而非整个结构体）。</p>
        <h5>8.4.1 指向结构体变量的指针</h5>
        <ol>
            <li><p>定义与初始化</p>
                <pre><code class='language-c' lang='c'>struct student {
    char name[20];
    int age;
    float score;
} stu = {&quot;Zhang San&quot;, 20, 90.5}, *p;
p = &amp;stu;  // 指针指向结构体变量stu
</code></pre>
            </li>
            <li><p>访问成员的两种方式</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    struct student {
        char name[20];
        int age;
        float score;
    } stu = {&quot;Zhang San&quot;, 20, 90.5}, *p = &amp;stu;

    // 方式1：(*p).成员名（括号不可省，.优先级高于*）
    printf(&quot;姓名：%s\n&quot;, (*p).name);

    // 方式2：p-&gt;成员名（结构体指针专用，推荐）
    printf(&quot;年龄：%d\n&quot;, p-&gt;age);
    printf(&quot;成绩：%.1f\n&quot;, p-&gt;score);

    // 修改成员值
    p-&gt;age = 21;
    (*p).score = 92.0;
    printf(&quot;修改后：年龄%d，成绩%.1f\n&quot;, p-&gt;age, p-&gt;score);
}
</code></pre>
            </li>

        </ol>
        <h5>8.4.2 指向结构体数组的指针</h5>
        <p>结构体数组名是数组首元素地址，指针可通过算术运算遍历数组：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    struct student {
        long num;
        char name[20];
        float score;
    } stud[3] = {
        {9701, &quot;LiMing&quot;, 98.0},
        {9702, &quot;WangDan&quot;, 95.0},
        {9703, &quot;LiHui&quot;, 80.0}
    }, *p = stud;  // 指向数组首元素

    // 遍历数组（三种方式等价）
    for (int i = 0; i &lt; 3; i++) {
        printf(&quot;学号：%ld，姓名：%s，成绩：%.1f\n&quot;,
               (p+i)-&gt;num,  // 指针偏移
               p[i].name,   // 数组下标
               (*(p+i)).score);  // 解引用+成员运算符
    }
}
</code></pre>
        <h5>8.4.3 结构体指针作为函数参数</h5>
        <p>传递结构体指针，避免结构体拷贝（节省内存），支持修改结构体内容，是结构体函数参数的首选方式。</p>
        <ol>
            <li>示例1：计算学生成绩总分与平均分</li>

        </ol>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#define N 5
// 定义结构体类型
typedef struct stud {
    char name[10];
    int s[3];  // 三门课成绩
    int sum;
    float ave;
} STUD;

// 结构体指针作为参数
void count(STUD *p) {
    p-&gt;sum = 0;
    for (int j = 0; j &lt; 3; j++) {
        p-&gt;sum += p-&gt;s[j];
    }
    p-&gt;ave = p-&gt;sum / 3.0;
}

void main() {
    STUD a[N];
    int i;
    // 输入学生信息
    for (i = 0; i &lt; N; i++) {
        printf(&quot;请输入第%d个学生的姓名和三门课成绩：\n&quot;, i+1);
        scanf(&quot;%s %d %d %d&quot;, a[i].name, &amp;a[i].s[0], &amp;a[i].s[1], &amp;a[i].s[2]);
        count(&amp;a[i]);  // 传递结构体地址
    }
    // 输出结果
    for (i = 0; i &lt; N; i++) {
        printf(&quot;姓名：%10s，成绩：%4d %4d %4d，总分：%6d，平均分：%.1f\n&quot;,
               a[i].name, a[i].s[0], a[i].s[1], a[i].s[2], a[i].sum, a[i].ave);
    }
}
</code></pre>
        <ol start='2' >
            <li>示例2：结构体数组指针遍历（打印学生信息）</li>

        </ol>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
typedef struct student {
    long num;
    char name[20];
    char sex;
    int age;
    double score;
    char addr[30];
} STU;

// 结构体数组指针作为参数
void printStu(STU *p, int n) {
    for (; p &lt; p + n; p++) {
        printf(&quot;学号：%ld，姓名：%s，性别：%c，年龄：%d，成绩：%.2f，地址：%s\n&quot;,
               p-&gt;num, p-&gt;name, p-&gt;sex, p-&gt;age, p-&gt;score, p-&gt;addr);
    }
}

void main() {
    STU a[3] = {
        {99641, &quot;Li Ping&quot;, &#39;M&#39;, 20, 56.0, &quot;Tianjin Street&quot;},
        {99341, &quot;Zhang Fan&quot;, &#39;F&#39;, 21, 78.0, &quot;Beijing Road&quot;},
        {99441, &quot;Ren Zhong&quot;, &#39;M&#39;, 19, 84.0, &quot;Shenyang Road&quot;}
    };
    printStu(a, 3);  // 传递数组名（首元素地址）
}
</code></pre>
        <h5>8.4.4 结构体指针的进阶应用（动态内存分配）</h5>
        <p>结合<code>malloc</code>动态分配结构体内存，灵活处理不确定数量的结构体数据：</p>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
typedef struct BOOK {
    char Name[50];
    double Price;
    int Pages;
} BOOK;

// 动态分配n本图书内存
BOOK *createBooks(int n) {
    BOOK *p = (BOOK *)malloc(n * sizeof(BOOK));
    if (p == NULL) {
        printf(&quot;内存分配失败\n&quot;);
        exit(1);
    }
    return p;
}

// 释放动态内存
void freeBooks(BOOK *p) {
    free(p);
    p = NULL;
}

void main() {
    int n;
    printf(&quot;请输入图书数量：&quot;);
    scanf(&quot;%d&quot;, &amp;n);
    BOOK *books = createBooks(n);

    // 输入图书信息
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;请输入第%d本书的书名、价格、页数：\n&quot;, i+1);
        scanf(&quot;%s %lf %d&quot;, books[i].Name, &amp;books[i].Price, &amp;books[i].Pages);
    }

    // 输出图书信息
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;书名：%s，价格：%.2f，页数：%d\n&quot;,
               (books+i)-&gt;Name, (books+i)-&gt;Price, (books+i)es);
    }

    freeBooks(books);
}
</code></pre>
        <p>&nbsp;</p>
        <h3>Chap9 指针高级应用与动态数据结构</h3>
        <p>核心结论：本章聚焦C语言指针的高级应用与动态数据管理，涵盖指针与函数的深度结合（返回指针的函数、函数指针、函数指针作为参数）、指针数组的定义与应用、命令行参数处理、复杂类型描述解读、二级指针，以及动态内存分配（malloc/calloc/realloc/free）与动态数据结构，是实现灵活模块化编程、动态数据管理和高效内存利用的核心知识点，为复杂程序开发提供关键技术支撑。</p>
        <h4>9.1 指针与函数</h4>
        <p>指针与函数的结合是模块化编程的核心技巧，包括返回指针的函数、指向函数的指针（函数指针），以及函数指针作为参数，实现函数的动态调用与灵活复用。</p>
        <h5>9.1.1 返回指针值的函数</h5>
        <p>函数的返回值可以是指向任意数据类型的指针，核心用于返回动态分配的内存、数组地址或复杂数据结构的地址。</p>
        <ul>
            <li><p>定义格式：<code>数据类型 *函数名(参数表);</code></p>
                <ul>
                    <li>说明：<code>*</code> 与函数名绑定，函数返回指向指定类型的指针。</li>

                </ul>
            </li>
            <li><p>注意事项：不可返回函数内局部变量的指针（局部变量栈区内存会随函数结束释放），可返回全局变量、静态变量或动态分配的内存地址。</p>
            </li>
            <li><p>示例：返回数组指定位置的指针</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int *search(int *x, int n) {
    int *p;
    p = x + n; // 指向数组x的第n个元素（下标从0开始）
    return p;
}

void main() {
    int arr[] = {10, 20, 30, 40, 50};
    int *p = search(arr, 2); // 指向arr[2]
    printf(&quot;arr[2] = %d\n&quot;, *p); // 输出30
}
</code></pre>
            </li>

        </ul>
        <h5>9.1.2 函数指针（指向函数的指针）</h5>
        <p>函数指针是指向函数入口地址的指针，可通过指针变量调用函数，实现函数的动态切换。</p>
        <ul>
            <li><p>定义格式：<code>返回值类型 (*指针名)(参数类型表);</code></p>
                <ul>
                    <li>关键区别：<code>int (*p)()</code> 是函数指针（指向返回int的函数），<code>int *p()</code> 是返回int指针的函数。</li>

                </ul>
            </li>
            <li><p>函数调用形式：<code>(*指针名)(实参表列);</code> 或直接 <code>指针名(实参表列);</code>（等价）</p>
            </li>
            <li><p>示例：用函数指针调用求最小值函数</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int min(int x, int y) {
    return x &lt; y ? x : y;
}

void main() {
    int (*funcPtr)(int, int); // 定义函数指针
    funcPtr = min; // 指向min函数（函数名即入口地址）
    int a = 15, b = 8;
    int m = (*funcPtr)(a, b); // 调用min函数
    printf(&quot;min(%d, %d) = %d\n&quot;, a, b, m); // 输出8
}
</code></pre>
            </li>

        </ul>
        <h5>9.1.3 函数指针作为函数参数</h5>
        <p>将函数指针作为参数传入其他函数，可在被调函数中动态调用不同功能的函数，提升代码灵活性。</p>
        <ul>
            <li><p>应用场景：实现通用处理函数（如process函数可动态调用max/min/add）</p>
            </li>
            <li><p>示例：用函数指针参数实现多功能计算</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
// 待传入的功能函数
int max(int x, int y) { printf(&quot;max=&quot;); return x &gt; y ? x : y; }
int min(int x, int y) { printf(&quot;min=&quot;); return x &lt; y ? x : y; }
int add(int x, int y) { printf(&quot;sum=&quot;); return x + y; }

// 接收函数指针参数的通用函数
void process(int x, int y, int (*fun)(int, int)) {
    int result = fun(x, y); // 调用传入的函数
    printf(&quot;%d\n&quot;, result);
}

void main() {
    int a = 10, b = 5;
    process(a, b, max);  // 调用max，输出max=10
    process(a, b, min);  // 调用min，输出min=5
    process(a, b, add);  // 调用add，输出sum=15
}
</code></pre>
            </li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>9.2 指针数组</h4>
        <p>指针数组是元素为指针的数组，核心用于存储多个字符串地址或数组地址，比二维数组更灵活（节省内存、便于修改指向）。</p>
        <h5>9.2.1 指针数组的定义</h5>
        <ul>
            <li><p>格式：<code>数据类型 *数组名[常量表达式];</code></p>
                <ul>
                    <li>说明：<code>[]</code> 优先级高于 <code>*</code>，数组的每个元素都是指向指定类型的指针。</li>

                </ul>
            </li>
            <li><p>与数组指针的区别：</p>
                <ul>
                    <li>指针数组 <code>int *a[4]</code>：4个元素，每个是int指针（存储地址）；</li>
                    <li>数组指针 <code>int (*a)[4]</code>：1个指针，指向含4个int元素的一维数组。</li>

                </ul>
            </li>

        </ul>
        <h5>9.2.2 指针数组的初始化</h5>
        <ul>
            <li><p>核心场景：存储多个字符串（字符串常量地址）</p>
            </li>
            <li><p>示例：字符串指针数组初始化</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    // 指针数组存储5个字符串的地址
    char *strArr[] = {&quot;Beijing&quot;, &quot;Jiaotong&quot;, &quot;University&quot;, &quot;C&quot;, &quot;Language&quot;};
    printf(&quot;strArr[1] = %s\n&quot;, strArr[1]);    // 输出Jiaotong
    printf(&quot;*(strArr+2) = %s\n&quot;, *(strArr+2));// 输出University
    printf(&quot;*strArr[3] = %c\n&quot;, *strArr[3]);  // 输出C（取第3个指针指向的首字符）
}
</code></pre>
            </li>

        </ul>
        <h5>9.2.3 指针数组的应用</h5>
        <ul>
            <li><p>典型场景：字符串排序（通过交换指针指向实现，无需移动字符串本身，效率高）</p>
            </li>
            <li><p>示例：指针数组实现字符串按字母顺序排序</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

// 排序函数：按ASCII码升序排序
void sort(char *name[], int n) {
    char *temp;
    int i, j, k;
    for (i = 0; i &lt; n-1; i++) {
        k = i;
        for (j = i+1; j &lt; n; j++) {
            // 比较两个字符串
            if (strcmp(name[k], name[j]) &gt; 0) {
                k = j; // 记录当前最小字符串的下标
            }
        }
        // 交换指针指向（不移动字符串）
        if (k != i) {
            temp = name[i];
            name[i] = name[k];
            name[k] = temp;
        }
    }
}

// 打印函数
void print(char *name[], int n) {
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%s\n&quot;, name[i]);
    }
}

void main() {
    char *name[] = {&quot;Follow me&quot;, &quot;BASIC&quot;, &quot;Great Wall&quot;, &quot;FORTRAN&quot;, &quot;Computer&quot;};
    int n = 5;
    sort(name, n);
    print(name, n);
    // 输出结果：BASIC、Computer、Follow me、FORTRAN、Great Wall
}
</code></pre>
            </li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>9.3 命令行参数</h4>
        <p>C程序可通过<code>main</code>函数的参数接收命令行输入的参数，实现程序的外部配置（如指定输入输出文件、运行模式）。</p>
        <h5>9.3.1 命令行参数的格式</h5>
        <ul>
            <li><p><code>main</code>函数的参数原型：<code>int main(int argc, char *argv[]);</code></p>
                <ul>
                    <li><p><code>argc</code>（argument count）：命令行参数的个数（包含程序名本身，最小为1）；</p>
                    </li>
                    <li><p><code>argv</code>（argument vector）：字符指针数组，每个元素指向一个命令行参数字符串；</p>
                        <ul>
                            <li><code>argv[0]</code>：程序可执行文件名；</li>
                            <li><code>argv[1]~argv[argc-1]</code>：用户输入的参数；</li>
                            <li><code>argv[argc]</code>：NULL（结束标志）。</li>

                        </ul>
                    </li>

                </ul>
            </li>

        </ul>
        <h5>9.3.2 示例：输出所有命令行参数</h5>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
int main(int argc, char *argv[]) {
    printf(&quot;参数个数 argc = %d\n&quot;, argc);
    for (int i = 0; i &lt; argc; i++) {
        printf(&quot;argv[%d]: %s\n&quot;, i, argv[i]);
    }
    return 0;
}
</code></pre>
        <ul>
            <li><p>运行命令：<code>./program.exe hello world 123</code></p>
            </li>
            <li><p>输出结果：</p>
                <pre><code>参数个数 argc = 4
argv[0]: ./program.exe
argv[1]: hello
argv[2]: world
argv[3]: 123
</code></pre>
            </li>

        </ul>
        <h5>9.3.3 注意事项</h5>
        <ul>
            <li>命令行参数以空格分隔；</li>
            <li>若参数包含空格，需用双引号包裹（如<code>&quot;hello world&quot;</code>视为一个参数）；</li>
            <li>IDE中设置命令行参数：需在项目配置的“调试”选项中指定“程序参数”。</li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>9.4 复杂类型描述与解读</h4>
        <p>C语言中复杂类型（如函数指针、指针数组、数组指针）的描述需遵循“右侧优先法则”，从标识符出发，先右后左解析。</p>
        <h5>9.4.1 解读原则</h5>
        <ol>
            <li>找到被定义的标识符，从标识符向外解析；</li>
            <li>优先级：<code>[]</code>（数组）和<code>()</code>（函数）高于<code>*</code>（指针）；</li>
            <li>结合性：<code>[]</code>和<code>()</code>从左向右，<code>*</code>从右向左。</li>

        </ol>
        <h5>9.4.2 常见复杂类型示例</h5>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>类型描述</th><th>解读结果</th></tr></thead>
            <tbody><tr><td><code>int (*p)[4]</code></td><td>p是指针，指向含4个int元素的一维数组</td></tr><tr><td><code>int *p[4]</code></td><td>p是数组，含4个int指针元素</td></tr><tr><td><code>int (*p)(int)</code></td><td>p是函数指针，指向返回int、参数为int的函数</td></tr><tr><td><code>int *(*p)(int)</code></td><td>p是函数指针，指向返回int指针、参数为int的函数</td></tr><tr><td><code>char **argv</code></td><td>argv是指针，指向char指针（二级指针）</td></tr></tbody>
        </table></figure>
        <hr />
        <p>&nbsp;</p>
        <h4>9.5 指向指针的指针（二级指针）</h4>
        <p>二级指针是指向指针变量的指针，核心用于处理指针数组、动态二维数组等场景。</p>
        <h5>9.5.1 定义与初始化</h5>
        <ul>
            <li><p>格式：<code>数据类型 **指针名;</code></p>
            </li>
            <li><p>核心关系：</p>
                <ul>
                    <li><code>**pp</code>：访问最终指向的数据；</li>
                    <li><code>*pp</code>：访问中间指针变量（一级指针）；</li>
                    <li><code>pp</code>：二级指针本身（存储一级指针的地址）。</li>

                </ul>
            </li>
            <li><p>示例：二级指针访问int变量</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    int a = 10;
    int *p = &amp;a;    // 一级指针，指向a
    int **pp = &amp;p;  // 二级指针，指向p

    printf(&quot;a = %d\n&quot;, a);
    printf(&quot;*p = %d\n&quot;, *p);       // 等价于a
    printf(&quot;**pp = %d\n&quot;, **pp);   // 等价于a
    printf(&quot;&amp;p = %p, pp = %p\n&quot;, &amp;p, pp); // 地址相同
}
</code></pre>
            </li>

        </ul>
        <h5>9.5.2 应用场景：处理指针数组</h5>
        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char *strArr[] = {&quot;Apple&quot;, &quot;Banana&quot;, &quot;Orange&quot;};
    char **pp = strArr; // 二级指针指向指针数组首元素（strArr[0]的地址）

    for (int i = 0; i &lt; 3; i++) {
        printf(&quot;strArr[%d]: %s\n&quot;, i, *(pp + i)); // 等价于strArr[i]
    }
}
</code></pre>
        <hr />
        <p>&nbsp;</p>
        <h4>9.6 动态数据结构与动态内存分配</h4>
        <p>静态数据结构（如数组）大小固定，动态内存分配通过<code>malloc/calloc/realloc/free</code>函数在堆区分配内存，实现灵活的内存管理（按需分配、释放）。</p>
        <h5>9.6.1 动态内存分配概述</h5>
        <ul>
            <li>堆区：程序运行时系统分配的内存区域，大小不固定，需手动申请和释放；</li>
            <li>核心函数：需包含头文件<code>#include &lt;stdlib.h&gt;</code>；</li>
            <li>常见场景：动态数组、动态结构体数组、链表等数据结构。</li>

        </ul>
        <h5>9.6.2 动态内存分配函数</h5>
        <ol>
            <li><p><code>malloc</code>：分配指定字节数的内存（未初始化）</p>
                <ul>
                    <li><p>原型：<code>void *malloc(unsigned int size);</code></p>
                    </li>
                    <li><p>示例：动态分配10个int元素的数组</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    int n = 10;
    int *arr = (int *)malloc(n * sizeof(int)); // 强制类型转换为int*
    if (arr == NULL) { // 检查分配是否成功
        printf(&quot;内存分配失败\n&quot;);
        exit(1);
    }
    // 初始化数组
    for (int i = 0; i &lt; n; i++) {
        arr[i] = i + 1;
    }
    // 输出
    for (int i = 0; i &lt; n; i++) {
        printf(&quot;%d &quot;, arr[i]); // 输出1 2 ... 10
    }
    free(arr); // 释放内存
    arr = NULL; // 避免野指针
}
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p><code>calloc</code>：分配n个指定大小的内存（初始化为0）</p>
                <ul>
                    <li><p>原型：<code>void *calloc(unsigned int n, unsigned int size);</code></p>
                    </li>
                    <li><p>示例：动态分配5个double元素的数组（初始为0）</p>
                        <pre><code class='language-c' lang='c'>double *dp = (double *)calloc(5, sizeof(double));
if (dp != NULL) {
    for (int i = 0; i &lt; 5; i++) {
        printf(&quot;%lf &quot;, dp[i]); // 输出0.000000 0.000000 ...
    }
}
free(dp);
dp = NULL;
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p><code>realloc</code>：重新分配已动态分配的内存（扩容/缩容）</p>
                <ul>
                    <li><p>原型：<code>void *realloc(void *p, unsigned int new_size);</code></p>
                    </li>
                    <li><p>注意：</p>
                        <ul>
                            <li>若原内存后有足够空间，直接扩容；否则分配新内存并复制原数据，释放原内存；</li>
                            <li>分配失败返回NULL，原内存不释放，需保存原指针。</li>

                        </ul>
                    </li>
                    <li><p>示例：将原数组扩容为15个int元素</p>
                        <pre><code class='language-c' lang='c'>int *arr = (int *)malloc(10 * sizeof(int));
int *new_arr = (int *)realloc(arr, 15 * sizeof(int));
if (new_arr != NULL) {
    arr = new_arr; // 指向新内存
    // 初始化新增元素
    for (int i = 10; i &lt; 15; i++) {
        arr[i] = i + 1;
    }
} else {
    printf(&quot;扩容失败\n&quot;);
    free(arr); // 释放原内存
}
free(arr);
arr = NULL;
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p><code>free</code>：释放动态分配的内存</p>
                <ul>
                    <li><p>原型：<code>void free(void *p);</code></p>
                    </li>
                    <li><p>注意：</p>
                        <ul>
                            <li>仅能释放堆区动态分配的内存，不可释放栈区变量（如局部数组）；</li>
                            <li>释放后指针变为野指针，需置为NULL；</li>
                            <li>不可重复释放同一内存。</li>

                        </ul>
                    </li>

                </ul>
            </li>

        </ol>
        <h5>9.6.3 动态内存分配的常见错误</h5>
        <ul>
            <li>内存泄漏：动态分配的内存未释放，程序运行期间持续占用；</li>
            <li>野指针：释放内存后未置NULL，继续访问该指针；</li>
            <li>越界访问：动态数组访问超出分配的大小；</li>
            <li>重复释放：同一内存被多次调用<code>free</code></li>

        </ul>
        <p>&nbsp;</p>
        <h3>Chap10 文件操作</h3>
        <p>核心结论：本章聚焦C语言文件操作的核心技术，基于ANSI C标准的<strong>缓冲文件系统</strong>，通过文件指针（FILE*）实现文件的打开-操作-关闭完整流程，涵盖文件分类、顺序读写（字符/字符串/数据块/格式化）、随机读写（位置定位）及文件错误检测，是实现数据持久化存储与读取的关键知识点，适用于文本文件和二进制文件的各类操作场景。</p>
        <h4>10.1 文件概述</h4>
        <p>文件是存储在外部介质（如磁盘）上的数据集合，操作系统以文件为单位管理数据。C语言通过库函数操作文件，核心依赖缓冲文件系统和文件指针。</p>
        <h5>10.1.1 文件分类</h5>
        <p>按不同标准可分为三类，核心区别如下：</p>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>分类标准</th><th>具体类别</th><th>特点/示例</th></tr></thead>
            <tbody><tr><td>按内容</td><td>程序文件（.c/.exe/.obj）</td><td>存储代码或可执行指令，如C源文件、可执行文件</td></tr><tr><td>&nbsp;</td><td>数据文件（.txt/.dat）</td><td>存储程序运行数据，如文本数据、二进制数据</td></tr><tr><td>按组织形式</td><td>顺序存取文件</td><td>只能按顺序读写，不可跳转（如磁带文件）</td></tr><tr><td>&nbsp;</td><td>随机存取文件</td><td>可通过指针定位任意位置读写（如磁盘文件）</td></tr><tr><td>按存储形式</td><td>ASCII码文件（文本文件）</td><td>字符以ASCII码存储，直观可读写，占空间大；如记事本文件</td></tr><tr><td>&nbsp;</td><td>二进制文件</td><td>按内存存储形式原样存储，占空间小、速度快，不可直接读写；如.exe/.obj文件</td></tr></tbody>
        </table></figure>
        <ul>
            <li><p>存储对比示例（十进制数12345）：</p>
                <ul>
                    <li>ASCII文件：占5字节，存储为<code>&#39;1&#39;(&#39;00110001&#39;)、&#39;2&#39;(&#39;00110010&#39;)、&#39;3&#39;(&#39;00110011&#39;)、&#39;4&#39;(&#39;00110100&#39;)、&#39;5&#39;(&#39;00110101&#39;)</code></li>
                    <li>二进制文件：占4字节（int型），存储为内存中整数12345的二进制形式</li>

                </ul>
            </li>

        </ul>
        <h5>10.1.2 C语言文件处理方法</h5>
        <ul>
            <li><p>缓冲文件系统（ANSI C标准唯一支持）：</p>
                <ul>
                    <li>系统自动为每个文件开辟<strong>512字节缓冲区</strong>，数据先写入缓冲区，装满后再写入磁盘；读取时先从磁盘读入缓冲区，再逐字节读取到变量。</li>
                    <li>优势：减少磁盘I/O次数，提高效率，由操作系统自动管理缓冲区。</li>

                </ul>
            </li>
            <li><p>非缓冲文件系统：需手动设置缓冲区，ANSI C不推荐，仅部分系统支持。</p>
            </li>

        </ul>
        <h5>10.1.3 文件类型指针（FILE*）</h5>
        <p>文件操作的核心是通过<strong>文件指针</strong>关联文件缓冲区，所有文件操作均通过指针实现。</p>
        <ol>
            <li><p>FILE结构体（系统定义）：
                存储文件相关信息（文件号、缓冲区状态、读写位置等），定义如下：</p>
                <pre><code class='language-c' lang='c'>typedef struct {
    int _fd;         // 文件号
    int _cleft;     // 缓冲区中剩余字符数
    int _mode;     // 文件操作方式
    char *_next;    // 文件当前读写位置
    char *_buff;    // 文件缓冲区地址
} FILE;
</code></pre>
            </li>
            <li><p>文件指针定义：</p>
                <ul>
                    <li>格式：<code>FILE *指针变量名;</code></li>
                    <li>示例：<code>FILE *fp;</code>（fp为文件指针，指向FILE结构体变量，关联文件缓冲区）</li>
                    <li>多文件操作：每个文件对应独立缓冲区和文件指针，互不干扰。</li>

                </ul>
            </li>

        </ol>
        <hr />
        <p>&nbsp;</p>
        <h4>10.2 文件的打开和关闭</h4>
        <p>文件操作必须遵循“<strong>先打开，后操作，最后关闭</strong>”的流程，核心函数为<code>fopen</code>（打开）和<code>fclose</code>（关闭）。</p>
        <h5>10.2.1 文件打开（fopen函数）</h5>
        <ul>
            <li><p>功能：申请文件缓冲区，建立文件与指针的关联，返回文件指针。</p>
            </li>
            <li><p>格式：<code>FILE *fopen(const char *文件名, const char *使用方式);</code></p>
                <ul>
                    <li>文件名：含路径（如<code>&quot;d:\\file\\test.txt&quot;</code>，双反斜杠转义），默认路径与程序同级。</li>
                    <li>使用方式：指定文件操作类型（读/写/追加、文本/二进制），核心类型如下：</li>

                </ul>
            </li>

        </ul>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>使用方式</th><th>含义</th><th>注意事项</th></tr></thead>
            <tbody><tr><td>&quot;r&quot;</td><td>只读打开文本文件</td><td>文件不存在则打开失败</td></tr><tr><td>&quot;w&quot;</td><td>只写创建文本文件</td><td>文件存在则覆盖原有内容，不存在则创建</td></tr><tr><td>&quot;a&quot;</td><td>追加打开文本文件</td><td>从文件末尾写入，不存在则创建</td></tr><tr><td>&quot;rb&quot;</td><td>只读打开二进制文件</td><td>-</td></tr><tr><td>&quot;wb&quot;</td><td>只写创建二进制文件</td><td>-</td></tr><tr><td>&quot;ab&quot;</td><td>追加打开二进制文件</td><td>-</td></tr><tr><td>&quot;r+&quot;</td><td>读写打开文本文件</td><td>文件必须存在</td></tr><tr><td>&quot;w+&quot;</td><td>读写创建文本文件</td><td>覆盖原有内容或创建新文件</td></tr><tr><td>&quot;a+&quot;</td><td>读写打开文本文件</td><td>从末尾写入，可读取全文</td></tr><tr><td>&quot;rb+&quot;</td><td>读写打开二进制文件</td><td>-</td></tr><tr><td>&quot;wb+&quot;</td><td>读写创建二进制文件</td><td>-</td></tr><tr><td>&quot;ab+&quot;</td><td>读写打开二进制文件</td><td>-</td></tr></tbody>
        </table></figure>
        <ul>
            <li><p>返回值：成功返回文件指针（非NULL），失败返回<code>NULL</code>（需判断打开状态）。</p>
            </li>
            <li><p>示例：打开文本文件（判断是否成功）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    FILE *fp;
    // 打开当前目录下的f1.txt，只读方式
    if ((fp = fopen(&quot;f1.txt&quot;, &quot;r&quot;)) == NULL) {
        printf(&quot;无法打开文件！\n&quot;);
        exit(1); // 终止程序，返回1表示出错
    }
    // 文件操作...
    fclose(fp); // 关闭文件
}
</code></pre>
            </li>

        </ul>
        <h5>10.2.2 文件关闭（fclose函数）</h5>
        <ul>
            <li><p>功能：断开指针与文件的关联，释放缓冲区数据到磁盘，回收缓冲区内存。</p>
            </li>
            <li><p>格式：<code>int fclose(FILE *fp);</code></p>
            </li>
            <li><p>返回值：成功返回<code>0</code>，失败返回<code>EOF</code>（-1）。</p>
            </li>
            <li><p>注意事项：</p>
                <ul>
                    <li>必须关闭文件，否则缓冲区数据可能丢失。</li>
                    <li>关闭后指针变为野指针，不可再操作。</li>

                </ul>
            </li>
            <li><p>示例：关闭文件</p>
                <pre><code class='language-c' lang='c'>FILE *fp = fopen(&quot;test.txt&quot;, &quot;w&quot;);
// 写入操作...
if (fclose(fp) != 0) {
    printf(&quot;文件关闭失败！\n&quot;);
}
</code></pre>
            </li>

        </ul>
        <h5>10.2.3 标准文件（系统自动打开）</h5>
        <p>程序运行时，系统自动打开3个标准文件，无需手动fopen：</p>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>标准文件</th><th>文件指针</th><th>对应设备</th><th>用途</th></tr></thead>
            <tbody><tr><td>标准输入</td><td>stdin</td><td>键盘</td><td>输入数据</td></tr><tr><td>标准输出</td><td>stdout</td><td>显示器</td><td>输出数据</td></tr><tr><td>标准出错输出</td><td>stderr</td><td>显示器</td><td>输出错误信息</td></tr></tbody>
        </table></figure>
        <ul>
            <li><p>示例：使用stdin读取字符串</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    char str[100];
    fgets(str, 100, stdin); // 从键盘读取字符串
    printf(&quot;%s&quot;, str);
}
</code></pre>
            </li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>10.3 文件的操作</h4>
        <p>文件操作分为<strong>顺序读写</strong>（按指针顺序移动）和<strong>随机读写</strong>（手动定位指针），核心是通过各类读写函数操作数据。</p>
        <h5>10.3.1 顺序读写</h5>
        <p>按文件内部位置指针的自然顺序读写，指针自动向后移动，核心函数如下：</p>
        <h6>1. 字符读写（fgetc / fputc）</h6>
        <ul>
            <li><p>读字符：<code>int fgetc(FILE *fp);</code></p>
                <ul>
                    <li><p>功能：从fp指向的文件读取一个字符，返回字符ASCII码（unsigned char转换为int）。</p>
                    </li>
                    <li><p>结束标志：读到文件末尾或出错返回<code>EOF</code>（-1）。</p>
                    </li>
                    <li><p>示例：读文本文件并输出到屏幕</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    FILE *fp;
    char ch;
    if ((fp = fopen(&quot;f1.txt&quot;, &quot;r&quot;)) == NULL) {
        printf(&quot;无法打开文件！\n&quot;);
        exit(1);
    }
    // 循环读取字符，直到EOF
    while ((ch = fgetc(fp)) != EOF) {
        putchar(ch); // 输出到屏幕
    }
    printf(&quot;\n&quot;);
    fclose(fp);
}
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p>写字符：<code>int fputc(int ch, FILE *fp);</code></p>
                <ul>
                    <li><p>功能：将字符ch（int型参数，实际取低8位）写入fp指向的文件。</p>
                    </li>
                    <li><p>返回值：成功返回写入的字符，失败返回<code>EOF</code>。</p>
                    </li>
                    <li><p>示例：从键盘输入字符，写入文件c2.txt</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    FILE *fp;
    char ch;
    if ((fp = fopen(&quot;c2.txt&quot;, &quot;w+&quot;)) == NULL) {
        printf(&quot;无法创建文件！\n&quot;);
        exit(1);
    }
    printf(&quot;输入字符串（回车结束）：\n&quot;);
    ch = getchar();
    while (ch != &#39;\n&#39;) {
        fputc(ch, fp); // 写入文件
        ch = getchar();
    }
    fclose(fp);
}
</code></pre>
                    </li>

                </ul>
            </li>

        </ul>
        <h6>2. 字符串读写（fgets / fputs）</h6>
        <ul>
            <li><p>读字符串：<code>char *fgets(char *buff, int n, FILE *fp);</code></p>
                <ul>
                    <li><p>功能：从fp读取<code>n-1</code>个字符到buff数组，遇换行或EOF提前结束，自动添加<code>&#39;\0&#39;</code>。</p>
                    </li>
                    <li><p>返回值：成功返回buff首地址，失败或EOF返回<code>NULL</code>。</p>
                    </li>
                    <li><p>示例：读文件中10个字符的字符串并输出</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    FILE *fp;
    char str[11]; // 存10个有效字符+&#39;\0&#39;
    if ((fp = fopen(&quot;c3.txt&quot;, &quot;r&quot;)) == NULL) {
        printf(&quot;无法打开文件！\n&quot;);
        exit(1);
    }
    fgets(str, 11, fp); // 最多读10个字符
    puts(str); // 输出字符串
    fclose(fp);
}
</code></pre>
                    </li>

                </ul>
            </li>
            <li><p>写字符串：<code>int fputs(const char *str, FILE *fp);</code></p>
                <ul>
                    <li><p>功能：将str指向的字符串（不含<code>&#39;\0&#39;</code>）写入fp指向的文件。</p>
                    </li>
                    <li><p>返回值：成功返回<code>0</code>，失败返回<code>EOF</code>。</p>
                    </li>
                    <li><p>示例：从键盘输入字符串，写入文件</p>
                        <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    FILE *fp;
    char st[20];
    if ((fp = fopen(&quot;c3.txt&quot;, &quot;w+&quot;)) == NULL) {
        printf(&quot;无法创建文件！\n&quot;);
        exit(1);
    }
    printf(&quot;输入字符串：\n&quot;);
    gets(st); // 读键盘输入
    fputs(st, fp); // 写入文件
    fclose(fp);
}
</code></pre>
                    </li>

                </ul>
            </li>

        </ul>
        <h6>3. 数据块读写（fread / fwrite）</h6>
        <p>多用于<strong>二进制文件</strong>，按数据块批量读写，效率高。</p>
        <ul>
            <li><p>读数据块：<code>size_t fread(void *buffer, size_t size, size_t count, FILE *fp);</code></p>
            </li>
            <li><p>写数据块：<code>size_t fwrite(const void *buffer, size_t size, size_t count, FILE *fp);</code></p>
                <ul>
                    <li><p>参数：</p>
                        <ul>
                            <li>buffer：数据存储地址（读时存数据，写时取数据）。</li>
                            <li>size：单个数据块的字节数（如<code>sizeof(int)</code>）。</li>
                            <li>count：数据块个数。</li>

                        </ul>
                    </li>
                    <li><p>返回值：成功读写的数据块个数（等于count为正常）。</p>
                    </li>

                </ul>
            </li>
            <li><p>示例1：将100个整数写入二进制文件，再读出</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    int Iarr[100], myarr[100], i;
    FILE *fp;
    // 初始化数组
    for (i = 0; i &lt; 100; i++) Iarr[i] = i;
    // 写入二进制文件
    if ((fp = fopen(&quot;test.dat&quot;, &quot;wb&quot;)) == NULL) {
        printf(&quot;无法创建文件！\n&quot;);
        exit(1);
    }
    fwrite(Iarr, sizeof(int), 100, fp);
    fclose(fp);
    // 读出文件
    if ((fp = fopen(&quot;test.dat&quot;, &quot;rb&quot;)) == NULL) {
        printf(&quot;无法打开文件！\n&quot;);
        exit(2);
    }
    if (fread(myarr, sizeof(int), 100, fp) != 100) {
        printf(&quot;数据读取不完整！\n&quot;);
        exit(3);
    }
    fclose(fp);
    // 输出结果
    for (i = 0; i &lt; 100; i++) printf(&quot;%d &quot;, myarr[i]);
}
</code></pre>
            </li>
            <li><p>示例2：结构体数组的二进制读写（商品信息）</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// 商品结构体
typedef struct GoodInfo {
    int nID;          // 商品ID
    char szName[20];  // 商品名称
    double dPrice;    // 商品价格
} GOODINFO;
// 商品列表结构体
typedef struct GoodList {
    GOODINFO Goods[100]; // 最多100种商品
    int nNumber;         // 实际商品数
} GOODLIST;

// 保存商品列表到文件
int SaveGoodListToFile(GOODLIST *gList, char *szFileName) {
    FILE *fp;
    if (gList-&gt;nNumber == 0) {
        printf(&quot;商品列表为空！\n&quot;);
        return -1;
    }
    fp = fopen(szFileName, &quot;wb+&quot;);
    if (fp == NULL) {
        printf(&quot;无法创建文件！\n&quot;);
        return -2;
    }
    // 先写商品个数，再写商品数据
    fwrite(&amp;gList-&gt;nNumber, sizeof(int), 1, fp);
    fwrite(gList-&gt;Goods, sizeof(GOODINFO), gList-&gt;nNumber, fp);
    fclose(fp);
    return 0;
}

// 从文件读取商品列表
int ReadGoodListFromFile(GOODLIST *gList, char *szFileName) {
    FILE *fp = fopen(szFileName, &quot;rb&quot;);
    if (fp == NULL) return -1;
    int n;
    // 读商品个数
    if (fread(&amp;n, sizeof(int), 1, fp) &lt; 1) {
        printf(&quot;文件无数据！\n&quot;);
        fclose(fp);
        return -2;
    }
    gList-&gt;nNumber = n;
    // 读商品数据
    int nCount = fread(gList-&gt;Goods, sizeof(GOODINFO), n, fp);
    if (nCount &lt; n) {
        printf(&quot;数据不完整！\n&quot;);
        fclose(fp);
        return -3;
    }
    fclose(fp);
    return 0;
}
</code></pre>
            </li>

        </ul>
        <h6>4. 格式化读写（fscanf / fprintf）</h6>
        <p>按指定格式读写文件，类似<code>scanf</code>/<code>printf</code>，但操作对象是文件。</p>
        <ul>
            <li><p>读格式：<code>int fscanf(FILE *fp, const char *format, ...);</code></p>
            </li>
            <li><p>写格式：<code>int fprintf(FILE *fp, const char *format, ...);</code></p>
            </li>
            <li><p>示例1：写入整数和字符串到文件</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    FILE *fp;
    int i = 617;
    char *s = &quot;That&#39;s good news&quot;;
    if ((fp = fopen(&quot;test.txt&quot;, &quot;w&quot;)) == NULL) {
        printf(&quot;无法创建文件！\n&quot;);
        exit(1);
    }
    fprintf(fp, &quot;%d%s&quot;, i, s); // 格式化写入
    fclose(fp);
}
</code></pre>
            </li>
            <li><p>示例2：读写整数、实数、字符</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    int a, a1;
    float b, b1;
    char c, c1;
    FILE *fp;
    // 读写模式打开文件
    if ((fp = fopen(&quot;new.txt&quot;, &quot;w+&quot;)) == NULL) {
        printf(&quot;无法创建文件！\n&quot;);
        exit(1);
    }
    // 从键盘输入并写入文件
    printf(&quot;请输入整数、实数、字符（用逗号分隔）：\n&quot;);
    scanf(&quot;%d,%f,%c&quot;, &amp;a, &amp;b, &amp;c);
    fprintf(fp, &quot;%d,%f,%c&quot;, a, b, c);
    fclose(fp);
    // 从文件读出并输出
    fp = fopen(&quot;new.txt&quot;, &quot;r&quot;);
    fscanf(fp, &quot;%d,%f,%c&quot;, &amp;a1, &amp;b1, &amp;c1);
    printf(&quot;原输入：%d,%f,%c\n&quot;, a, b, c);
    printf(&quot;文件读出：%d,%f,%c\n&quot;, a1, b1, c1);
    fclose(fp);
}
</code></pre>
            </li>
            <li><p>示例3：学生成绩的格式化读写</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;malloc.h&gt;
// 学生成绩结构体
typedef struct StudentScores {
    char szID[9];    // 学号
    char szName[20]; // 姓名
    double dScores[3]; // 三门课成绩
} STUDENTSCORES;
// 班级成绩结构体
typedef struct ClassScore {
    STUDENTSCORES *pStudents; // 学生数组指针
    int nCount;              // 学生个数
} CLASSSCORE;

// 从文件读入班级成绩
void ReadScoresFromFile(CLASSSCORE *pClass, char *szFileName) {
    FILE *fp = fopen(szFileName, &quot;r&quot;);
    if (fp == NULL) return;
    // 读学生个数
    fscanf(fp, &quot;%d&quot;, &amp;pClass-&gt;nCount);
    // 动态分配学生数组内存
    pClass-&gt;pStudents = (STUDENTSCORES*)malloc(sizeof(STUDENTSCORES) * pClass-&gt;nCount);
    // 逐行读学生数据
    for (int i = 0; i &lt; pClass-&gt;nCount; i++) {
        fscanf(fp, &quot;%s %s %lf %lf %lf&quot;,
               pClass-&gt;pStudents[i].szID,
               pClass-&gt;pStudents[i].szName,
               &amp;pClass-&gt;pStudents[i].dScores[0],
               &amp;pClass-&gt;pStudents[i].dScores[1],
               &amp;pClass-&gt;pStudents[i].dScores[2]);
    }
    fclose(fp);
}

// 将班级成绩写入文件
void SaveScoresToFile(CLASSSCORE *pClass, char *szFileName) {
    FILE *fp = fopen(szFileName, &quot;w&quot;);
    if (fp == NULL) return;
    // 写学生个数
    fprintf(fp, &quot;%d\n&quot;, pClass-&gt;nCount);
    // 逐行写学生数据
    for (int i = 0; i &lt; pClass-&gt;nCount; i++) {
        fprintf(fp, &quot;%s %s %6.2lf %6.2lf %6.2lf\n&quot;,
               pClass-&gt;pStudents[i].szID,
               pClass-&gt;pStudents[i].szName,
               pClass-&gt;pStudents[i].dScores[0],
               pClass-&gt;pStudents[i].dScores[1],
               pClass-&gt;pStudents[i].dScores[2]);
    }
    fclose(fp);
}
</code></pre>
            </li>

        </ul>
        <h5>10.3.2 随机读写</h5>
        <p>通过定位文件内部的<strong>位置指针</strong>，实现任意位置的读写，核心是文件定位函数。</p>
        <h6>1. 位置指针概述</h6>
        <ul>
            <li><p>文件内部有一个隐含的位置指针，指向当前读写位置：</p>
                <ul>
                    <li>打开文件时，指针指向文件开头（“r”/“w”模式）或文件末尾（“a”模式）。</li>
                    <li>顺序读写时，指针自动向后移动（移动字节数=读写数据的字节数）。</li>
                    <li>随机读写时，通过函数手动调整指针位置。</li>

                </ul>
            </li>

        </ul>
        <h6>2. 文件定位函数</h6>
        <ul>
            <li><p>指针复位：<code>void rewind(FILE *fp);</code></p>
                <ul>
                    <li>功能：将fp的位置指针移到文件开头。</li>

                </ul>
            </li>
            <li><p>指针偏移：<code>int fseek(FILE *fp, long offset, int base);</code></p>
                <ul>
                    <li><p>功能：将指针从base基准位置偏移offset字节。</p>
                    </li>
                    <li><p>参数：</p>
                        <ul>
                            <li><p>offset：偏移量（正数向后移，负数向前移）。</p>
                            </li>
                            <li><p>base：基准位置（宏定义）：</p>
                                <figure class='table-figure'><table>
                                    <thead>
                                    <tr><th>基准位置</th><th>宏名</th><th>数值</th></tr></thead>
                                    <tbody><tr><td>文件开头</td><td>SEEK_SET</td><td>0</td></tr><tr><td>当前指针位置</td><td>SEEK_CUR</td><td>1</td></tr><tr><td>文件末尾</td><td>SEEK_END</td><td>2</td></tr></tbody>
                                </table></figure>
                            </li>

                        </ul>
                    </li>
                    <li><p>返回值：成功返回<code>0</code>，失败返回<code>-1</code>。</p>
                    </li>

                </ul>
            </li>
            <li><p>示例：读取文件中第二个学生的数据</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
// 学生结构体
struct stu {
    char name[10];
    int num;
    int age;
    char addr[15];
} stu1, *qq = &amp;stu1;

void main() {
    FILE *fp;
    // 打开二进制文件
    if ((fp = fopen(&quot;stu.dat&quot;, &quot;rb&quot;)) == NULL) {
        printf(&quot;无法打开文件！\n&quot;);
        exit(1);
    }
    rewind(fp); // 指针移到文件开头
    // 指针偏移一个学生结构体的字节数（指向第二个学生）
    fseek(fp, sizeof(struct stu), SEEK_SET);
    // 读取第二个学生数据
    fread(qq, sizeof(struct stu), 1, fp);
    // 输出结果
    printf(&quot;姓名：%s 学号：%d 年龄：%d 地址：%s\n&quot;,
           qq-&gt;name, qq-&gt;num, qq-&gt;age, qq-&gt;addr);
    fclose(fp);
}
</code></pre>
            </li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>10.4 文件检测</h4>
        <p>用于判断文件操作是否出错、是否到达文件末尾，核心函数为<code>ferror</code>、<code>clearerr</code>、<code>feof</code>。</p>
        <h5>10.4.1 错误检测（ferror函数）</h5>
        <ul>
            <li><p>格式：<code>int ferror(FILE *fp);</code></p>
            </li>
            <li><p>功能：检测fp指向的文件操作是否出错。</p>
            </li>
            <li><p>返回值：<code>0</code>（未出错），非0（出错）。</p>
            </li>
            <li><p>示例：检测文件读写错误</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    FILE *fp;
    fp = fopen(&quot;DUMMY.FIL&quot;, &quot;w&quot;); // 只写模式打开
    fgetc(fp); // 尝试读文件（非法操作）
    if (ferror(fp)) { // 检测错误
        printf(&quot;文件操作出错！\n&quot;);
        clearerr(fp); // 清除错误标志
    }
    fclose(fp);
}
</code></pre>
            </li>

        </ul>
        <h5>10.4.2 清除错误标志（clearerr函数）</h5>
        <ul>
            <li>格式：<code>void clearerr(FILE *fp);</code></li>
            <li>功能：将fp的“错误标志”和“文件结束标志”置为<code>0</code>。</li>
            <li>注意：<code>ferror</code>检测到错误后，标志会保持，需手动清除。</li>

        </ul>
        <h5>10.4.3 文件结束检测（feof函数）</h5>
        <ul>
            <li><p>格式：<code>int feof(FILE *fp);</code></p>
            </li>
            <li><p>功能：检测fp指向的文件是否到达末尾。</p>
            </li>
            <li><p>返回值：<code>0</code>（未结束），非0（已结束）。</p>
            </li>
            <li><p>注意：<code>fgetc</code>返回<code>EOF</code>可能是出错或文件结束，需用<code>feof</code>区分。</p>
            </li>
            <li><p>示例：区分文件结束和出错</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
void main() {
    FILE *fp;
    char ch;
    fp = fopen(&quot;test.txt&quot;, &quot;r&quot;);
    while (1) {
        ch = fgetc(fp);
        if (feof(fp)) { // 检测是否文件结束
            printf(&quot;文件读取完毕！\n&quot;);
            break;
        }
        if (ferror(fp)) { // 检测是否出错
            printf(&quot;读取错误！\n&quot;);
            break;
        }
        putchar(ch);
    }
    fclose(fp);
}
</code></pre>
            </li>

        </ul>
        <hr />
        <p>&nbsp;</p>
        <h4>10.5 总结与应用实例</h4>
        <h5>10.5.1 常见错误</h5>
        <ol>
            <li>打开/关闭方式不匹配（如“r”模式写文件）。</li>
            <li>混淆文件指针（FILE*）和位置指针（内部隐含指针）。</li>
            <li>随机读写时指针定位错误。</li>
            <li>忘记关闭文件，导致数据丢失。</li>

        </ol>
        <h5>10.5.2 常用文件函数汇总</h5>
        <figure class='table-figure'><table>
            <thead>
            <tr><th>分类</th><th>函数名</th><th>功能</th></tr></thead>
            <tbody><tr><td>打开关闭</td><td>fopen</td><td>打开文件</td></tr><tr><td>&nbsp;</td><td>fclose</td><td>关闭文件</td></tr><tr><td>定位</td><td>rewind</td><td>指针移到文件开头</td></tr><tr><td>&nbsp;</td><td>fseek</td><td>指针偏移指定字节</td></tr><tr><td>字符读写</td><td>fgetc</td><td>读一个字符</td></tr><tr><td>&nbsp;</td><td>fputc</td><td>写一个字符</td></tr><tr><td>字符串读写</td><td>fgets</td><td>读一个字符串</td></tr><tr><td>&nbsp;</td><td>fputs</td><td>写一个字符串</td></tr><tr><td>数据块读写</td><td>fread</td><td>读数据块（二进制）</td></tr><tr><td>&nbsp;</td><td>fwrite</td><td>写数据块（二进制）</td></tr><tr><td>格式化读写</td><td>fscanf</td><td>格式化读文件</td></tr><tr><td>&nbsp;</td><td>fprintf</td><td>格式化写文件</td></tr><tr><td>状态检测</td><td>ferror</td><td>检测操作错误</td></tr><tr><td>&nbsp;</td><td>clearerr</td><td>清除错误标志</td></tr><tr><td>&nbsp;</td><td>feof</td><td>检测文件结束</td></tr></tbody>
        </table></figure>
        <h5>10.5.3 应用实例：文件复制并转换大小写</h5>
        <ul>
            <li><p>功能：将file1.txt的内容复制到file2.txt，同时将小写字母转为大写。</p>
                <pre><code class='language-c' lang='c'>#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
void main() {
    FILE *fp1, *fp2;
    char ch;
    // 打开源文件（读）和目标文件（写）
    if ((fp1 = fopen(&quot;file1.txt&quot;, &quot;r&quot;)) == NULL) {
        printf(&quot;无法打开源文件！\n&quot;);
        exit(1);
    }
    if ((fp2 = fopen(&quot;file2.txt&quot;, &quot;w&quot;)) == NULL) {
        printf(&quot;无法创建目标文件！\n&quot;);
        fclose(fp1);
        exit(2);
    }
    // 循环读取并转换
    ch = fgetc(fp1);
    while (ch != EOF) {
        if (ch &gt;= &#39;a&#39; &amp;&amp; ch &lt;= &#39;z&#39;) {
            ch -= 32; // 小写转大写（ASCII码差32）
        }
        fputc(ch, fp2); // 写入目标文件
        ch = fgetc(fp1);
    }
    // 关闭文件
    fclose(fp1);
    fclose(fp2);
    printf(&quot;复制完成！\n&quot;);
}
</code></pre>
            </li>

        </ul>
        <p>&nbsp;</p>


        <!-- 返回主页面按钮 -->
        <div style="margin-top: 2rem;">
            <a href="index.html#notes" class="btn">
                <i class="fas fa-arrow-left"></i> 返回学习笔记主页
            </a>
            <!-- 【替换】可添加笔记下载链接 -->
            <a href="https://raw.githubusercontent.com/kayi-er/kayiwen.github.io/main/download/%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93.pdf" target="_blank" class="btn" style="margin-left: 1rem;">
                <i class="fas fa-download"></i> 下载笔记PDF
            </a>
        </div>
    </section>

    <!-- 页脚 -->
    <footer>
        <!-- 【替换】版权信息 -->
        <p>&copy; 2026 kayiwen - C语言学习笔记 | 基于GitHub Pages搭建</p>
    </footer>
</main>
<!-- ===== 以上是你已完成的C语言笔记主体内容 ===== -->

<!-- 子菜单交互脚本 -->
<script>
    const notesTrigger = document.getElementById('notes-trigger');
    const notesSubmenu = document.getElementById('notes-submenu');

    notesTrigger.addEventListener('click', function(e) {
        e.preventDefault();
        notesSubmenu.classList.toggle('submenu-open');
        this.classList.toggle('active');
    });

    const mainNavItems = document.querySelectorAll('.nav-main-item');
    mainNavItems.forEach(item => {
        if (item.id !== 'notes-trigger') {
            item.addEventListener('click', function() {
                notesSubmenu.classList.remove('submenu-open');
                notesTrigger.classList.remove('active');
            });
        }
    });
</script>
</body>
</html>